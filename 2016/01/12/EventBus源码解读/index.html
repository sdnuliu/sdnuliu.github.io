<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>EventBus源码解读 | Mr.Liu的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="之前写了EventBus的使用详解，下面来详细分析一下EventBus的源码吧。   转载相关博客：EventBus源码研读:http://kymjs.com/code/2015/12/16/01EXECUTORSERVICE线程池讲解：http://www.cnphp6.com/archives/61093EventBus源码解析:http://www.trinea.cn/android/eve">
<meta name="keywords" content="EventBus,Android,GitHub">
<meta property="og:type" content="article">
<meta property="og:title" content="EventBus源码解读">
<meta property="og:url" content="http://blogliu.com.cn/2016/01/12/EventBus源码解读/index.html">
<meta property="og:site_name" content="Mr.Liu的博客">
<meta property="og:description" content="之前写了EventBus的使用详解，下面来详细分析一下EventBus的源码吧。   转载相关博客：EventBus源码研读:http://kymjs.com/code/2015/12/16/01EXECUTORSERVICE线程池讲解：http://www.cnphp6.com/archives/61093EventBus源码解析:http://www.trinea.cn/android/eve">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2016-01-12T14:35:06.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="EventBus源码解读">
<meta name="twitter:description" content="之前写了EventBus的使用详解，下面来详细分析一下EventBus的源码吧。   转载相关博客：EventBus源码研读:http://kymjs.com/code/2015/12/16/01EXECUTORSERVICE线程池讲解：http://www.cnphp6.com/archives/61093EventBus源码解析:http://www.trinea.cn/android/eve">
  
    <link rel="alternate" href="/atom.xml" title="Mr.Liu的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Mr.Liu的博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">攻城狮的博客</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/archives">目录</a>
        
          <a class="main-nav-link" href="/about">关于我</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://blogliu.com.cn"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-EventBus源码解读" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/01/12/EventBus源码解读/" class="article-date">
  <time datetime="2016-01-12T07:51:10.000Z" itemprop="datePublished">2016-01-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/移动开发/">移动开发</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      EventBus源码解读
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>之前写了EventBus的使用详解，下面来详细分析一下EventBus的源码吧。  </p>
<p>转载相关博客：<br>EventBus源码研读:<a href="http://kymjs.com/code/2015/12/16/01" target="_blank" rel="noopener">http://kymjs.com/code/2015/12/16/01</a><br>EXECUTORSERVICE线程池讲解：<a href="http://www.cnphp6.com/archives/61093" target="_blank" rel="noopener">http://www.cnphp6.com/archives/61093</a><br>EventBus源码解析:<a href="http://www.trinea.cn/android/eventbus-source-analysis/" target="_blank" rel="noopener">http://www.trinea.cn/android/eventbus-source-analysis/</a><br>彻底理解ThreadLocal:<a href="http://blog.csdn.net/lufeng20/article/details/24314381" target="_blank" rel="noopener">http://blog.csdn.net/lufeng20/article/details/24314381</a></p>
<h1 id="进入源码世界"><a href="#进入源码世界" class="headerlink" title="进入源码世界"></a>进入源码世界</h1><h2 id="入口类EventBus类"><a href="#入口类EventBus类" class="headerlink" title="入口类EventBus类"></a>入口类EventBus类</h2><p>从使用的流程来看，首先是EventBus#getDefault()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EventBus <span class="title">getDefault</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(defaultInstance == <span class="keyword">null</span>)&#123;</span><br><span class="line">		<span class="keyword">synchronized</span>(EventBus.class)&#123;</span><br><span class="line">			<span class="keyword">if</span>(defaultInstance == <span class="keyword">null</span>)&#123;</span><br><span class="line">				defaultInstance = <span class="keyword">new</span> EventBus();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> defaultInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出是一个单例模式，调用构造方法，再看构造方法，调用一个重载的构造方法，重载的构造方法又需要一个EventBusBuilder对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">EventBus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>(DEFAULT_BUILDER);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EventBus(EventBusBuilder builder) &#123;</span><br><span class="line">       ......</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h2 id="EventBusBuilder类"><a href="#EventBusBuilder类" class="headerlink" title="EventBusBuilder类"></a>EventBusBuilder类</h2><p>这个类主要用来创建EventBus对象使用。包含的属性也是EventBus的一些参数设置，build函数用于新建EventBus对象,installDefaultEventBus函数将当前设置应用于Default EventBus。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EventBusBuilder</span> </span>&#123;</span><br><span class="line">   	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ExecutorService DEFAULT_EXECUTOR_SERVICE = Executors.newCachedThreadPool();</span><br><span class="line">   	<span class="keyword">boolean</span> logSubscriberExceptions = <span class="keyword">true</span>;</span><br><span class="line">   	<span class="keyword">boolean</span> logNoSubscriberMessages = <span class="keyword">true</span>;</span><br><span class="line">   	<span class="keyword">boolean</span> sendSubscriberExceptionEvent = <span class="keyword">true</span>;</span><br><span class="line">   	<span class="keyword">boolean</span> sendNoSubscriberEvent = <span class="keyword">true</span>;</span><br><span class="line">   	<span class="keyword">boolean</span> throwSubscriberException;</span><br><span class="line">   	<span class="keyword">boolean</span> eventInheritance = <span class="keyword">true</span>;</span><br><span class="line">   	ExecutorService executorService;</span><br><span class="line">   	List&lt;Class&lt;?&gt;&gt; skipMethodVerificationForClasses;</span><br><span class="line"></span><br><span class="line">   	EventBusBuilder() &#123;</span><br><span class="line">       	<span class="keyword">this</span>.executorService = DEFAULT_EXECUTOR_SERVICE;</span><br><span class="line">   	&#125;</span><br><span class="line">   	......</span><br><span class="line">  	&#125;</span><br></pre></td></tr></table></figure>
<p>longSubscriberExceptions :当调用事件处理函数异常时是否打印异常信息，默认为true<br>longNoSubscriberMessages :没有订阅者订阅该事件时是否打印日志，默认为true<br>sendSubscriberExceptionEvent :当调用事件处理函数异常时是否发送SubscriberExceptionEvent事件，如果此开关打开，订阅者可以通过  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(SubscriberExceptionEvent event&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">	......</span></span></span><br><span class="line"><span class="function"><span class="params">&#125;</span></span></span><br></pre></td></tr></table></figure></p>
<p>订阅该事件进行处理，默认为true.</p>
<p>sendNoSubscriberEvent :如果没有订阅者，发送一条默认事件<br>throwSubscriberException :当调用事件处理函数异常时是否抛出异常，默认为false,可通过<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EventBus.builder().</span><br><span class="line">throwSubscriberException(<span class="keyword">true</span>).installDefaultEventBus()</span><br></pre></td></tr></table></figure></p>
<p>打开。<br>eventInheritance :event的子类是否也能响应订阅者<br>executorService :异步，BackGround处理方式的线程池  </p>
<p>通过上面可以看出，EventBus.getDefault()方法会创建一个默认的EventBusBuilder，如果我们想修改EventBusBuilder的一些配置选项，可以通过EventBus.builder()方法生成一个EventBusBuidler,然后设置自定义配置选项，最后调用installDefaultEventBus方法创建一个EventBus对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> EventBus <span class="title">installDefaultEventBus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       Class var1 = EventBus.class;</span><br><span class="line">       <span class="keyword">synchronized</span>(EventBus.class) &#123;</span><br><span class="line">           <span class="keyword">if</span>(EventBus.defaultInstance != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Default instance already exists. It may be only set once before it\'s used the first time to ensure consistent behavior."</span>);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               EventBus.defaultInstance = <span class="keyword">this</span>.build();</span><br><span class="line">               <span class="keyword">return</span> EventBus.defaultInstance;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h2 id="三个Poster类"><a href="#三个Poster类" class="headerlink" title="三个Poster类"></a>三个Poster类</h2><p>分析完EventBusBuilder，再来看EventBus的构造方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">EventBus(EventBusBuilder builder) &#123;</span><br><span class="line">       <span class="keyword">this</span>.currentPostingThreadState = <span class="keyword">new</span> ThreadLocal() &#123;</span><br><span class="line">           <span class="keyword">protected</span> EventBus.<span class="function">PostingThreadState <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">new</span> EventBus.PostingThreadState();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;;</span><br><span class="line">       <span class="keyword">this</span>.subscriptionsByEventType = <span class="keyword">new</span> HashMap();</span><br><span class="line">       <span class="keyword">this</span>.typesBySubscriber = <span class="keyword">new</span> HashMap();</span><br><span class="line">       <span class="keyword">this</span>.stickyEvents = <span class="keyword">new</span> ConcurrentHashMap();</span><br><span class="line">       <span class="keyword">this</span>.mainThreadPoster = <span class="keyword">new</span> HandlerPoster(<span class="keyword">this</span>, Looper.getMainLooper(), <span class="number">10</span>);</span><br><span class="line">       <span class="keyword">this</span>.backgroundPoster = <span class="keyword">new</span> BackgroundPoster(<span class="keyword">this</span>);</span><br><span class="line">       <span class="keyword">this</span>.asyncPoster = <span class="keyword">new</span> AsyncPoster(<span class="keyword">this</span>);</span><br><span class="line">       <span class="keyword">this</span>.subscriberMethodFinder = <span class="keyword">new</span> SubscriberMethodFinder(builder.skipMethodVerificationForClasses);</span><br><span class="line">       <span class="keyword">this</span>.logSubscriberExceptions = builder.logSubscriberExceptions;</span><br><span class="line">       <span class="keyword">this</span>.logNoSubscriberMessages = builder.logNoSubscriberMessages;</span><br><span class="line">       <span class="keyword">this</span>.sendSubscriberExceptionEvent = builder.sendSubscriberExceptionEvent;</span><br><span class="line">       <span class="keyword">this</span>.sendNoSubscriberEvent = builder.sendNoSubscriberEvent;</span><br><span class="line">       <span class="keyword">this</span>.throwSubscriberException = builder.throwSubscriberException;</span><br><span class="line">       <span class="keyword">this</span>.eventInheritance = builder.eventInheritance;</span><br><span class="line">       <span class="keyword">this</span>.executorService = builder.executorService;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>HandlerPoster、BackgroundPoster、AsyncPoster<br>HandlerPoster:前台发送者<br>BackgroundPoster:后台发送者<br>AsyncPoster:后台发送者，只让队列的最后一个待订阅者去响应</p>
<p>每个Poster中都有一个任务队列，PendingPostQueue<br>PendingPostQueue中定义了两个节点，队列的头节点和尾节点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> PendingPost head;</span><br><span class="line">   <span class="keyword">private</span> PendingPost tail;</span><br></pre></td></tr></table></figure>
<p>PengdingPost类的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PendingPost</span> </span>&#123;</span><br><span class="line">   	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;PendingPost&gt; pendingPostPool = <span class="keyword">new</span> ArrayList();</span><br><span class="line">   	Object event;</span><br><span class="line">   	Subscription subscription;</span><br><span class="line">   	PendingPost next;</span><br><span class="line">   	......</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>首先提供了一个池的设计，类似于我们的线程池，目的是为了减少对象创建的开销，当一个对象不用了，我们可以留着它，下次再需要的时候返回这个保留的而不是再去创建。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> PendingPost <span class="title">obtainPendingPost</span><span class="params">(Subscription subscription, Object event)</span> </span>&#123;</span><br><span class="line">        List var2 = pendingPostPool;</span><br><span class="line">        <span class="keyword">synchronized</span>(pendingPostPool) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = pendingPostPool.size();</span><br><span class="line">            <span class="keyword">if</span>(size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                PendingPost pendingPost = (PendingPost)pendingPostPool.remove(size - <span class="number">1</span>);</span><br><span class="line">                pendingPost.event = event;</span><br><span class="line">                pendingPost.subscription = subscription;</span><br><span class="line">                pendingPost.next = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">return</span> pendingPost;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PendingPost(event, subscription);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的方法会检查线程池中是否有可复用的，如果有可用的，返回可复用对象，如果没有可复用的，创建一个新的PendingPost对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">releasePendingPost</span><span class="params">(PendingPost pendingPost)</span> </span>&#123;</span><br><span class="line">        pendingPost.event = <span class="keyword">null</span>;</span><br><span class="line">        pendingPost.subscription = <span class="keyword">null</span>;</span><br><span class="line">        pendingPost.next = <span class="keyword">null</span>;</span><br><span class="line">        List var1 = pendingPostPool;</span><br><span class="line">        <span class="keyword">synchronized</span>(pendingPostPool) &#123;</span><br><span class="line">            <span class="keyword">if</span>(pendingPostPool.size() &lt; <span class="number">10000</span>) &#123;</span><br><span class="line">                pendingPostPool.add(pendingPost);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述方法回收PengingPost对象，为了防止池无线增长，增加了size&lt;1000的判断。</p>
<p>PendingPost分析完之后，我们看PendingPostQueue的出列和入列方式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(PendingPost pendingPost)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(pendingPost == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"null cannot be enqueued"</span>);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">if</span>(<span class="keyword">this</span>.tail != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">this</span>.tail.next = pendingPost;</span><br><span class="line">               <span class="keyword">this</span>.tail = pendingPost;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">if</span>(<span class="keyword">this</span>.head != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Head present, but no tail"</span>);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">this</span>.head = <span class="keyword">this</span>.tail = pendingPost;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">this</span>.notifyAll();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>首先是入列方式，tail尾的next指向当前正在入队的节点，tail指向自己（自己变成了最后一个节点），完成入队。如果是第一个元素，将head和tail都指向自己就可以了。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> PendingPost <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        PendingPost pendingPost = <span class="keyword">this</span>.head;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.head = <span class="keyword">this</span>.head.next;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.head == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.tail = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pendingPost;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>pendingPost为要出队的节点，将head指向head的next，完成出队，如果只有一个元素，tail置空。</p>
<p>PendingPostQueue再往上一级，是HandlerPost的enqueue方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Subscription subscription, Object event)</span> </span>&#123;</span><br><span class="line">        PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event);</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.queue.enqueue(pendingPost);</span><br><span class="line">            <span class="keyword">if</span>(!<span class="keyword">this</span>.handlerActive) &#123;</span><br><span class="line">                <span class="keyword">this</span>.handlerActive = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(!<span class="keyword">this</span>.sendMessage(<span class="keyword">this</span>.obtainMessage())) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Could not send handler message"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>根据输入参数，生成待发送对象PendingPost,然后加入队列，如果此时handlerActive是false的话，发送一条空的消息激活handler,然后是handleMessage()方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">boolean</span> rescheduled = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">long</span> started = SystemClock.uptimeMillis();</span><br><span class="line"></span><br><span class="line">           <span class="keyword">long</span> timeInMethod;</span><br><span class="line">           <span class="keyword">do</span> &#123;</span><br><span class="line">               PendingPost pendingPost = <span class="keyword">this</span>.queue.poll();</span><br><span class="line">               <span class="keyword">if</span>(pendingPost == <span class="keyword">null</span>) &#123;</span><br><span class="line">                   <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">                       pendingPost = <span class="keyword">this</span>.queue.poll();</span><br><span class="line">                       <span class="keyword">if</span>(pendingPost == <span class="keyword">null</span>) &#123;</span><br><span class="line">                           <span class="keyword">this</span>.handlerActive = <span class="keyword">false</span>;</span><br><span class="line">                           <span class="keyword">return</span>;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">this</span>.eventBus.invokeSubscriber(pendingPost);</span><br><span class="line">               timeInMethod = SystemClock.uptimeMillis() - started;</span><br><span class="line">           &#125; <span class="keyword">while</span>(timeInMethod &lt; (<span class="keyword">long</span>)<span class="keyword">this</span>.maxMillisInsideHandleMessage);</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span>(!<span class="keyword">this</span>.sendMessage(<span class="keyword">this</span>.obtainMessage())) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Could not send handler message"</span>);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           rescheduled = <span class="keyword">true</span>;</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="keyword">this</span>.handlerActive = rescheduled;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>handleMessage不停的去待发送队列queue中去取消息（timeInMehtod&lt;maxMillisInsideHandleMessage,加判断为了防止主线程ANR），最终通过eventBus的invokeSubscriber方法发送出去，让注册了的订阅者去响应。<br>关于BackgroundPoster、AsyncPoster原理与HandlerPoster类似，这两个是工作在异步，实现Runnable接口，用到了ExecutorService。</p>
<h2 id="Subscribe流程"><a href="#Subscribe流程" class="headerlink" title="Subscribe流程"></a>Subscribe流程</h2><p>分析完EventBus的构造函数，下面看一下入口方法register().</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Object subscriber, <span class="keyword">boolean</span> sticky, <span class="keyword">int</span> priority)</span> </span>&#123;</span><br><span class="line">        List subscriberMethods = <span class="keyword">this</span>.subscriberMethodFinder.findSubscriberMethods(subscriber.getClass());</span><br><span class="line">        Iterator var5 = subscriberMethods.iterator();</span><br><span class="line">        <span class="keyword">while</span>(var5.hasNext()) &#123;</span><br><span class="line">            SubscriberMethod subscriberMethod = (SubscriberMethod)var5.next();</span><br><span class="line">            <span class="keyword">this</span>.subscribe(subscriber, subscriberMethod, sticky, priority);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="SubscriberMethod类"><a href="#SubscriberMethod类" class="headerlink" title="SubscriberMethod类"></a>SubscriberMethod类</h3><p>从字面意思是订阅者方法，看看类中的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Method method;</span><br><span class="line">   <span class="keyword">final</span> ThreadMode threadMode;</span><br><span class="line">   <span class="keyword">final</span> Class&lt;?&gt; eventType;</span><br><span class="line">   String methodString;</span><br><span class="line">   SubscriberMethod(Method method, ThreadMode threadMode, Class&lt;?&gt; eventType) &#123;</span><br><span class="line">       <span class="keyword">this</span>.method = method;</span><br><span class="line">       <span class="keyword">this</span>.threadMode = threadMode;</span><br><span class="line">       <span class="keyword">this</span>.eventType = eventType;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">checkMethodString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(<span class="keyword">this</span>.methodString == <span class="keyword">null</span>) &#123;</span><br><span class="line">           StringBuilder builder = <span class="keyword">new</span> StringBuilder(<span class="number">64</span>);</span><br><span class="line">           builder.append(<span class="keyword">this</span>.method.getDeclaringClass().getName());</span><br><span class="line">           builder.append(<span class="string">'#'</span>).append(<span class="keyword">this</span>.method.getName());</span><br><span class="line">           builder.append(<span class="string">'('</span>).append(<span class="keyword">this</span>.eventType.getName());</span><br><span class="line">           <span class="keyword">this</span>.methodString = builder.toString();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>Method：方法名<br>ThreadMode:一个枚举类<br>checkMehtodString()方法是为了设置变量methodString的值  </p>
<h3 id="SubscriberMethodFinder类"><a href="#SubscriberMethodFinder类" class="headerlink" title="SubscriberMethodFinder类"></a>SubscriberMethodFinder类</h3><p>subscriberMethodFinder类主要是通过反射的方法来判断传入的this对象中是否有onEvent开头的方法的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">filterSubscriberMethods</span><span class="params">(List&lt;SubscriberMethod&gt; subscriberMethods,</span></span></span><br><span class="line"><span class="function"><span class="params">                                         HashMap&lt;String, Class&gt; eventTypesFound, StringBuilder methodKeyBuilder,</span></span></span><br><span class="line"><span class="function"><span class="params">                                         Method[] methods)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">            String methodName = method.getName();</span><br><span class="line">            <span class="keyword">if</span> (methodName.startsWith(ON_EVENT_METHOD_NAME)) &#123;</span><br><span class="line">                <span class="keyword">int</span> modifiers = method.getModifiers();</span><br><span class="line">                Class&lt;?&gt; methodClass = method.getDeclaringClass();</span><br><span class="line">                <span class="keyword">if</span> ((modifiers &amp; Modifier.PUBLIC) != <span class="number">0</span> &amp;&amp; (modifiers &amp; MODIFIERS_IGNORE) == <span class="number">0</span>) &#123;</span><br><span class="line">                ......</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>通过对全部的方法遍历，为了效率首先做一次筛选，只关注我们的以 “onEvent” 开头的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ThreadMode <span class="title">getThreadMode</span><span class="params">(Class&lt;?&gt; clazz, Method method, String methodName)</span> </span>&#123;</span><br><span class="line">        String modifierString = methodName.substring(ON_EVENT_METHOD_NAME.length());</span><br><span class="line">        ThreadMode threadMode;</span><br><span class="line">        <span class="keyword">if</span> (modifierString.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            threadMode = ThreadMode.PostThread;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (modifierString.equals(<span class="string">"MainThread"</span>)) &#123;</span><br><span class="line">            threadMode = ThreadMode.MainThread;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (modifierString.equals(<span class="string">"BackgroundThread"</span>)) &#123;</span><br><span class="line">            threadMode = ThreadMode.BackgroundThread;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (modifierString.equals(<span class="string">"Async"</span>)) &#123;</span><br><span class="line">            threadMode = ThreadMode.Async;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!skipMethodVerificationForClasses.containsKey(clazz)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Illegal onEvent method, check for typos: "</span> + method);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                threadMode = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> threadMode;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里我们看到，其实EventBus不仅仅支持onEvent()的回调，它还支持onEventMainThread()、onEventBackgroundThread()、onEventAsync()这三个方法的回调。<br>一直到最后，我们看到这个方法把所有的方法名集合作为value，类名作为key存入了 methodCache 这个全局静态变量中。意味着，整个库在运行期间所有遍历的方法都会存在这个 map 中，而不必每次都去做耗时的反射取方法了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(methodCache) &#123;</span><br><span class="line">   methodCache.put(subscriberClass, subscriberMethods1);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(methodCache) &#123;</span><br><span class="line">     subscriberMethods = (List)methodCache.get(subscriberClass);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h2 id="事件的处理与发送subscribe"><a href="#事件的处理与发送subscribe" class="headerlink" title="事件的处理与发送subscribe()"></a>事件的处理与发送subscribe()</h2><p>subscribe()方法方法接收四个参数：订阅者封装的对象、响应方法名封装的对象、是否为粘滞事件、这条事件的优先级。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// Must be called in synchronized block</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(Object subscriber, SubscriberMethod subscriberMethod, <span class="keyword">boolean</span> sticky, <span class="keyword">int</span> priority)</span> </span>&#123;</span><br><span class="line">        Class&lt;?&gt; eventType = subscriberMethod.eventType;</span><br><span class="line">        CopyOnWriteArrayList&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType);</span><br><span class="line">        Subscription newSubscription = <span class="keyword">new</span> Subscription(subscriber, subscriberMethod, priority);</span><br><span class="line">        <span class="keyword">if</span> (subscriptions == <span class="keyword">null</span>) &#123;</span><br><span class="line">            subscriptions = <span class="keyword">new</span> CopyOnWriteArrayList&lt;Subscription&gt;();</span><br><span class="line">            subscriptionsByEventType.put(eventType, subscriptions);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (subscriptions.contains(newSubscription)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Subscriber "</span> + subscriber.getClass() + <span class="string">" already registered to event "</span></span><br><span class="line">                        + eventType);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Starting with EventBus 2.2 we enforced methods to be public (might change with annotations again)</span></span><br><span class="line">        <span class="comment">// subscriberMethod.method.setAccessible(true);</span></span><br><span class="line">        <span class="keyword">int</span> size = subscriptions.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= size; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == size || newSubscription.priority &gt; subscriptions.get(i).priority) &#123;</span><br><span class="line">                subscriptions.add(i, newSubscription);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Class&lt;?&gt;&gt; subscribedEvents = typesBySubscriber.get(subscriber);</span><br><span class="line">        <span class="keyword">if</span> (subscribedEvents == <span class="keyword">null</span>) &#123;</span><br><span class="line">            subscribedEvents = <span class="keyword">new</span> ArrayList&lt;Class&lt;?&gt;&gt;();</span><br><span class="line">            typesBySubscriber.put(subscriber, subscribedEvents);</span><br><span class="line">        &#125;</span><br><span class="line">        subscribedEvents.add(eventType);</span><br><span class="line">        .......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个订阅者是可以有多个重载的onEvent()方法的，所以这里多做了一步，将所有订阅者的响应方法保存到subscribedEvents中。</p>
<p>注：子事件也可以让响应父事件的 onEvent() 。这个有点绕，举个例子，订阅者的onEvent(CharSequence),如果传一个String类型的值进去，默认情况下是不会响应的，但如果我们在构建的时候设置了 eventInheritance 为 true ,那么它就会响应了。</p>
<h2 id="post-方法调用流程"><a href="#post-方法调用流程" class="headerlink" title="post()方法调用流程"></a>post()方法调用流程</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">post</span><span class="params">(Object event)</span> </span>&#123;</span><br><span class="line">        PostingThreadState postingState = currentPostingThreadState.get();</span><br><span class="line">        List&lt;Object&gt; eventQueue = postingState.eventQueue;</span><br><span class="line">        eventQueue.add(event);</span><br><span class="line">        <span class="keyword">if</span> (!postingState.isPosting) &#123;</span><br><span class="line">            postingState.isMainThread = Looper.getMainLooper() == Looper.myLooper();</span><br><span class="line">            postingState.isPosting = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (postingState.canceled) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Internal error. Abort state was not reset"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (!eventQueue.isEmpty()) &#123;</span><br><span class="line">                    postSingleEvent(eventQueue.remove(<span class="number">0</span>), postingState);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                postingState.isPosting = <span class="keyword">false</span>;</span><br><span class="line">                postingState.isMainThread = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>post() 方法首先从 currentPostingThreadState 对象中取了一个 PostingThreadState ，我们来看看这个 currentPostingThreadState 对象的创建代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ThreadLocal&lt;PostingThreadState&gt; currentPostingThreadState = <span class="keyword">new</span></span><br><span class="line">ThreadLocal&lt;PostingThreadState&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> PostingThreadState <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PostingThreadState();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>ThreadLocal 是一个线程内部的数据存储类，通过它可以在指定的线程中存储数据，而这段数据是不会与其他线程共享的。其内部原理是通过生成一个它包裹的泛型对象的数组，在不同的线程会有不同的数组索引值，通过这样就可以做到每个线程通过 get() 方法获取的时候，取到的只能是自己线程所对应的数据。<br>在 EventBus 中， ThreadLocal 所包裹的是一个 PostingThreadState 类，它仅仅是封装了一些事件发送中过程所需的数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PostingThreadState</span> </span>&#123;</span><br><span class="line">    <span class="comment">//通过post方法参数传入的事件集合</span></span><br><span class="line">    <span class="keyword">final</span> List&lt;Object&gt; eventQueue = <span class="keyword">new</span> ArrayList&lt;Object&gt;(); </span><br><span class="line">    <span class="keyword">boolean</span> isPosting; <span class="comment">//是否正在执行postSingleEvent()方法</span></span><br><span class="line">    <span class="keyword">boolean</span> isMainThread;</span><br><span class="line">    Subscription subscription;</span><br><span class="line">    Object event;</span><br><span class="line">    <span class="keyword">boolean</span> canceled;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>回到 post() 方法，我们看到其核心代码是这句：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!eventQueue.isEmpty()) &#123;</span><br><span class="line">    postSingleEvent(eventQueue.remove(<span class="number">0</span>), postingState);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>次调用post()的时候都会传入一个事件，这个事件会被加入到队列。而每次执行postSingleEvent()都会从队列中取出一个事件，这样不停循环取出事件处理，直到队列全部取完。<br>再看 postSingleEvent() 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postSingleEvent</span><span class="params">(Object event, PostingThreadState postingState)</span> <span class="keyword">throws</span> Error </span>&#123;</span><br><span class="line">    Class&lt;?&gt; eventClass = event.getClass();</span><br><span class="line">    <span class="keyword">boolean</span> subscriptionFound = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (eventInheritance) &#123;</span><br><span class="line">        <span class="comment">//获取到eventClass所有父类的集合</span></span><br><span class="line">        List&lt;Class&lt;?&gt;&gt; eventTypes = lookupAllEventTypes(eventClass);</span><br><span class="line">        <span class="keyword">int</span> countTypes = eventTypes.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> h = <span class="number">0</span>; h &lt; countTypes; h++) &#123;</span><br><span class="line">            Class&lt;?&gt; clazz = eventTypes.get(h);</span><br><span class="line">            <span class="comment">//左或右只要有一个为真则为真,并赋值给左</span></span><br><span class="line">            subscriptionFound |= postSingleEventForEventType(event, postingState, clazz);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        subscriptionFound = postSingleEventForEventType(event, postingState, eventClass);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!subscriptionFound) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logNoSubscriberMessages) &#123;</span><br><span class="line">            Log.d(TAG, <span class="string">"No subscribers registered for event "</span> + eventClass);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//参考sendNoSubscriberEvent注释</span></span><br><span class="line">        <span class="keyword">if</span> (sendNoSubscriberEvent &amp;&amp; eventClass != NoSubscriberEvent.class &amp;&amp;</span><br><span class="line">                eventClass != SubscriberExceptionEvent.class) &#123;</span><br><span class="line">            post(<span class="keyword">new</span> NoSubscriberEvent(<span class="keyword">this</span>, event));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还记得 EventBusBuild 中的 eventInheritance是做什么的吗？它表示一个子类事件能否响应父类的 onEvent() 方法。<br>再往下看 lookupAllEventTypes() 它通过循环和递归一起用，将一个类的父类,接口,父类的接口,父类接口的父类,全部添加到全局静态变量 eventTypes 集合中。之所以用全局静态变量的好处在于用全局静态变量只需要将那耗时又复杂的循环+递归方法执行一次就够了，下次只需要通过 key:事件类名 来判断这个事件是否以及执行过 lookupAllEventTypes() 方法。</p>
<h3 id="postSingleEventForEventType-方法"><a href="#postSingleEventForEventType-方法" class="headerlink" title="postSingleEventForEventType()方法"></a>postSingleEventForEventType()方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">postSingleEventForEventType</span><span class="params">(Object event, PostingThreadState postingState, Class&lt;?&gt; eventClass)</span> </span>&#123;</span><br><span class="line">    CopyOnWriteArrayList&lt;Subscription&gt; subscriptions;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">//所有订阅了eventClass的事件集合</span></span><br><span class="line">        subscriptions = subscriptionsByEventType.get(eventClass);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (subscriptions != <span class="keyword">null</span> &amp;&amp; !subscriptions.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">//回调subscription的响应方法</span></span><br><span class="line">        <span class="keyword">for</span> (Subscription subscription : subscriptions) &#123;</span><br><span class="line">            postingState.event = event;</span><br><span class="line">            postingState.subscription = subscription;</span><br><span class="line">            <span class="keyword">boolean</span> aborted = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                postToSubscription(subscription, event, postingState.isMainThread);</span><br><span class="line">                aborted = postingState.canceled;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                postingState.event = <span class="keyword">null</span>;</span><br><span class="line">                postingState.subscription = <span class="keyword">null</span>;</span><br><span class="line">                postingState.canceled = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (aborted) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获取到所有订阅了 eventClass 的事件集合，之前有讲过， subscriptionsByEventType 是一个以 key:订阅的事件 value:订阅这个事件的所有订阅者集合 的 Map 。<br>最后通过循环，遍历所有订阅了 eventClass 事件的订阅者，并向每一个订阅者发送事件。<br>看它的发送事件的方法：<br>postToSubscription(subscription, event, postingState.isMainThread);<br>噢，又回到了和之前 Subscribe 流程中处理粘滞事件相同的方法里————对声明不同线程模式的事件做不同的响应方法，最终都是通过invokeSubscriber()反射订阅者类中的以onEvent开头的方法。</p>
<h2 id="unregister"><a href="#unregister" class="headerlink" title="unregister()"></a>unregister()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">unregister</span><span class="params">(Object subscriber)</span> </span>&#123;</span><br><span class="line">    List&lt;Class&lt;?&gt;&gt; subscribedTypes = typesBySubscriber.get(subscriber);</span><br><span class="line">    <span class="keyword">if</span> (subscribedTypes != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Class&lt;?&gt; eventType : subscribedTypes) &#123;</span><br><span class="line">            <span class="comment">//取消注册subscriber对eventType事件的响应</span></span><br><span class="line">            unsubscribeByEventType(subscriber, eventType);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当subscriber对所有事件都不响应以后,移除订阅者</span></span><br><span class="line">        typesBySubscriber.remove(subscriber);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之前讲过typesBySubscriber key:订阅者对象 value:这个订阅者订阅的事件集合，表示当前订阅者订阅了哪些事件。<br>首先遍历要取消注册的订阅者订阅的每一个事件，调用unsubscribeByEventType(),从这个事件的所有订阅者集合中将要取消注册的订阅者移除。最后再以：当前订阅者为 key 全部订阅事件集合为 value 的一个 Map 的 Entry 移除，就完成了取消注册的全部过程。</p>
<h2 id="EventBus工作原理"><a href="#EventBus工作原理" class="headerlink" title="EventBus工作原理"></a>EventBus工作原理</h2><p>最后我们再来从设计者的角度看一看EventBus的工作原理。</p>
<h3 id="订阅的逻辑"><a href="#订阅的逻辑" class="headerlink" title="订阅的逻辑"></a>订阅的逻辑</h3><p>1、首先是调用register()方法注册一个订阅者A。<br>2、遍历这个订阅者A的全部以onEvent开头的订阅方法。<br>3、将A订阅的所有事件分别作为 key，所有能响应 key 事件的订阅者的集合作为 value，存入 Map&lt;事件，List&lt;订阅这个事件的订阅者&gt;&gt;。   4、以A的类名为 key，所有 onEvent 参数类型的类名组成的集合为 value，存入 Map&lt;订阅者，List&lt;订阅的事件&gt;&gt;。<br> 4.1、如果是订阅了粘滞事件的订阅者，从粘滞事件缓存区获取之前发送过的粘滞事件，响应这些粘滞事件。</p>
<h3 id="发送事件的逻辑"><a href="#发送事件的逻辑" class="headerlink" title="发送事件的逻辑"></a>发送事件的逻辑</h3><p>1、取当前线程的发送事件封装数据，并从封装的数据中拿到发送事件的事件队列。<br>2、将要发送的事件加入到事件队列中去。<br>3、循环，每次发送队列中的一条事件给所有订阅了这个事件的订阅者。<br>3.1、如果是子事件可以响应父事件的事件模式，需要先将这个事件的所有父类、接口、父类的接口、父类接口的父类都找到，并让订阅了这些父类信息的订阅者也都响应这条事件。</p>
<h3 id="响应事件的逻辑"><a href="#响应事件的逻辑" class="headerlink" title="响应事件的逻辑"></a>响应事件的逻辑</h3><p>1、发送事件处理完成后会将事件交给负责响应的逻辑部分。<br>2、首先判断时间的响应模式，响应模式分为四种：<br>PostThread 在哪个线程调用的post()方法，就在哪个线程执行响应方法。<br>MainThread 无论是在哪个线程调用的post()方法，最终都在主线程执行响应方法。<br>BackgroundThread 无论是在哪个线程调用的post()方法，最终都在后台线程执行响应方法。(串行执行，一次只执行一个任务，其他任务在队列中处于等待状态)<br>Async 无论是在哪个线程调用的post()方法，最终都在后台线程执行响应方法。(并行执行，只要有任务就开一个线程让他执行)</p>
<h3 id="取消注册的逻辑"><a href="#取消注册的逻辑" class="headerlink" title="取消注册的逻辑"></a>取消注册的逻辑</h3><p>1、首先是调用unregister()方法拿到要取消注册的订阅者B。<br>2、从这个类订阅的时候存入的 Map&lt;订阅者，List&lt;订阅的事件&gt;&gt; 中，拿到这个类的订阅事件集合。<br>3、遍历订阅时间集合，在注册的时候存入的 Map&lt;事件，List&lt;订阅这个事件的订阅者&gt;&gt; 中将对应订阅事件的订阅者集合中的这个订阅者移除。<br>   4、将步骤2中的 Map&lt;订阅者，List&lt;订阅的事件&gt;&gt; 中这个订阅者相关的 Entry 移除。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blogliu.com.cn/2016/01/12/EventBus源码解读/" data-id="cjotn6f74001h9b0ip2lroedi" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/EventBus/">EventBus</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/GitHub/">GitHub</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2016/08/03/说点什么/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          说点什么
        
      </div>
    </a>
  
  
    <a href="/2016/01/10/2016-做更好的自己/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">2016,变成更好的自己</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/MarkDown/">MarkDown</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/心情随笔/">心情随笔</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/移动开发/">移动开发</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android/">Android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/EventBus/">EventBus</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/GitHub/">GitHub</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MarkDown/">MarkDown</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/生活/">生活</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/笔记/">笔记</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/编辑器/">编辑器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/读书/">读书</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/随笔/">随笔</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/Android/" style="font-size: 15px;">Android</a> <a href="/tags/EventBus/" style="font-size: 15px;">EventBus</a> <a href="/tags/GitHub/" style="font-size: 15px;">GitHub</a> <a href="/tags/MarkDown/" style="font-size: 10px;">MarkDown</a> <a href="/tags/生活/" style="font-size: 20px;">生活</a> <a href="/tags/笔记/" style="font-size: 15px;">笔记</a> <a href="/tags/编辑器/" style="font-size: 10px;">编辑器</a> <a href="/tags/读书/" style="font-size: 15px;">读书</a> <a href="/tags/随笔/" style="font-size: 20px;">随笔</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">一月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">十二月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">八月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/01/">一月 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/01/18/Android群英传读书笔记系列（二）/">Android群英传读书笔记系列（二）</a>
          </li>
        
          <li>
            <a href="/2017/01/16/工作以来的一些感悟/">工作以来的一些感悟</a>
          </li>
        
          <li>
            <a href="/2017/01/15/Android群英传读书笔记系列（一）/">Android群英传读书笔记系列（一）</a>
          </li>
        
          <li>
            <a href="/2016/12/12/轻松搞定MarkDown/">轻松搞定MarkDown</a>
          </li>
        
          <li>
            <a href="/2016/12/10/再会/">再会</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 Liu Teng<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">目录</a>
  
    <a href="/about" class="mobile-nav-link">关于我</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>