<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>刘腾的博客</title>
  
  <subtitle>攻城狮的博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blogliu.com.cn/"/>
  <updated>2018-11-25T13:44:04.257Z</updated>
  <id>http://blogliu.com.cn/</id>
  
  <author>
    <name>Liu Teng</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>HTML常用标签</title>
    <link href="http://blogliu.com.cn/posts/16a89419/"/>
    <id>http://blogliu.com.cn/posts/16a89419/</id>
    <published>2018-11-25T12:38:00.000Z</published>
    <updated>2018-11-25T13:44:04.257Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HTML常用标签"><a href="#HTML常用标签" class="headerlink" title="HTML常用标签"></a>HTML常用标签</h2><h3 id="1-布局标签-amp-语义化"><a href="#1-布局标签-amp-语义化" class="headerlink" title="1.布局标签&amp;语义化"></a>1.布局标签&amp;语义化</h3><p>1.<code>&lt;div&gt;</code>:定义块级元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">【特点】元素独占一行，元素前后会自动换行，主要用于网页布局。多用于组合其他HTML元素，本身无实在意义。</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;wrap-container&quot;&gt;</span><br><span class="line">        &lt;div id=&quot;collapsed-container&quot;&gt;&lt;/div&gt;</span><br><span class="line">        &lt;div id=&quot;expanded-container&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><p>2.<code>&lt;span&gt;</code>:行内元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">多个元素在一行内显示，与div标签区别在于，span随内容而占用高宽空间（紧贴内容），而一对div标签却占用一行。</span><br></pre></td></tr></table></figure><p>3.<code>&lt;header&gt;</code>:定义区段或页面的页眉</p><p>4.<code>&lt;footer&gt;</code>:定义区段或页面的页脚</p><p>5.<code>&lt;section&gt;</code>:定义文档中的区段</p><p>6.<code>&lt;article&gt;</code>:定义文章</p><p>7.<code>&lt;aside&gt;</code>:定义页面内容之外的内容</p><p>8.<code>&lt;dialog&gt;</code>:定义对话框或窗口</p><p>9.<code>&lt;nav&gt;</code>:定义导航</p><p>10.<code>&lt;hgroup&gt;</code>:定义标题组</p><h3 id="2-表格标签"><a href="#2-表格标签" class="headerlink" title="2.表格标签"></a>2.表格标签</h3><p>1.<code>&lt;table&gt;</code>:定义表格.</p><p>2.<code>&lt;thead&gt;</code>:定义页眉.</p><p>3.<code>&lt;tbody&gt;</code>:定义主体.</p><p>4.<code>&lt;tfoot&gt;</code>:定义页脚.</p><p>5.<code>&lt;caption&gt;</code>:定义标题.</p><p>6.<code>&lt;th&gt;</code>:定义表头.</p><p>7.<code>&lt;tr&gt;</code>:定义一行.</p><p>8.<code>&lt;td&gt;</code>:定义单元格.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;table&gt;</span><br><span class="line">  &lt;tr&gt;</span><br><span class="line">    &lt;td&gt;John&lt;/td&gt;</span><br><span class="line">    &lt;td&gt;Doe&lt;/td&gt;</span><br><span class="line">  &lt;/tr&gt;</span><br><span class="line">  &lt;tr&gt;</span><br><span class="line">    &lt;td&gt;Jane&lt;/td&gt;</span><br><span class="line">    &lt;td&gt;Doe&lt;/td&gt;</span><br><span class="line">  &lt;/tr&gt;</span><br><span class="line">&lt;/table&gt;</span><br></pre></td></tr></table></figure><h3 id="3-表单标签"><a href="#3-表单标签" class="headerlink" title="3.表单标签"></a>3.表单标签</h3><p>1.<code>&lt;form&gt;</code>:定义表单.(表单包含在form标签中)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">常见属性</span><br><span class="line">    action：提交的服务器地址</span><br><span class="line">    method：表单数据提交的方式，取值： get：明文提交/post：隐式提交</span><br><span class="line">    name：定义表单名称，JS用到的比较多</span><br><span class="line">    id： 独一无二的标识</span><br><span class="line">如：&lt;form action=&quot;url&quot; method=&quot;get/post&quot;&gt; &lt;/form&gt;</span><br></pre></td></tr></table></figure><p>2<code>&lt;input&gt;</code>:定义输入域.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">【主要属性】</span><br><span class="line">    type：根据不同的type属性值可以创建各种类型的输入字段</span><br><span class="line">    value：最终提交给服务器的值</span><br><span class="line">    name：控件的名称，提供给服务器使用，没有name，控件则无法提交</span><br><span class="line">    id：唯一标识，只能在当前页面使用，服务器不能用</span><br><span class="line">        disabled：禁用，不能被提交</span><br><span class="line"></span><br><span class="line">(1）文本框：&lt;input type=&quot;text&quot;&gt;</span><br><span class="line">(2）密码框：&lt;input type=&quot;password&quot;&gt;</span><br><span class="line"> 【专有属性】</span><br><span class="line">  maxlength：限制输入的字符数，取值：数字</span><br><span class="line">  eadonly：设置文本控件只读</span><br><span class="line">（3）单选按钮：&lt;input type=&quot;radio&quot;&gt;</span><br><span class="line">（4）复选框：&lt;input type=&quot;checkbox&quot;&gt;</span><br><span class="line">【专有属性】</span><br><span class="line">         checked，设置默认被选中</span><br><span class="line">（5）提交按钮：&lt;input type=&quot;submit&quot;&gt;</span><br><span class="line">（6）重置按钮：&lt;input type=&quot;reset&quot;&gt;</span><br><span class="line">（7）普通按钮：&lt;input type=&quot;button&quot;&gt;</span><br><span class="line">（8）图片按钮：&lt;input type=&quot;image&quot; src=&quot;&quot;&gt; </span><br><span class="line">（9）隐藏域：&lt;input type=&quot;hidden&quot;&gt;</span><br><span class="line">（10）文件选择框：&lt;input type=&quot;file&quot;&gt;</span><br></pre></td></tr></table></figure><p>3.<code>&lt;textarea&gt;</code>:定义文本域.(多行)</p><p>4.<code>&lt;select&gt;</code>、<code>&lt;option&gt;</code>:下拉选择框</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;section name=&quot;&quot;&gt;</span><br><span class="line">  &lt;option value=&quot;&quot; selected&gt;&lt;/option&gt;</span><br><span class="line">&lt;/section&gt;</span><br></pre></td></tr></table></figure><h3 id="4-列表标签"><a href="#4-列表标签" class="headerlink" title="4.列表标签"></a>4.列表标签</h3><p>1.<code>&lt;ul&gt;</code>:定义无序列表.</p><p>2.<code>&lt;ol&gt;</code>:定义有序列表.</p><p>3.<code>&lt;li&gt;</code>:定义列表项.</p><p>4.<code>&lt;dl&gt;</code>:定义自定义列表.</p><p>5.<code>&lt;dt&gt;</code>:定义自定义列表项.</p><p>6.<code>&lt;dd&gt;</code>:定义自定义的描述.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">有序列表</span><br><span class="line"></span><br><span class="line">&lt;ol&gt;</span><br><span class="line">    &lt;li&gt;&lt;/li&gt;</span><br><span class="line">&lt;/ol&gt;</span><br><span class="line"></span><br><span class="line">无序列表</span><br><span class="line"></span><br><span class="line">&lt;ul&gt;</span><br><span class="line">     &lt;li&gt;&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">自定义列表</span><br><span class="line"></span><br><span class="line">&lt;dl&gt;</span><br><span class="line">  &lt;dt&gt;列表中的标题内容&lt;/dt&gt;</span><br><span class="line">  &lt;dd&gt;列表中的数据&lt;/dd&gt;</span><br><span class="line">&lt;/dl&gt;</span><br></pre></td></tr></table></figure><h3 id="5-图像-amp-链接标签"><a href="#5-图像-amp-链接标签" class="headerlink" title="5.图像&amp;链接标签"></a>5.图像&amp;链接标签</h3><p>1.<code>&lt;img&gt;</code>:定义图像.注意加上alt属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">【标签】&lt;img&gt;</span><br><span class="line">【属性】</span><br><span class="line">        src：图片地址（绝对/相对）</span><br><span class="line">        width：图像宽度</span><br><span class="line">        height：图像高度</span><br><span class="line"></span><br><span class="line">1）绝对路径：从文件所在的最高级目录下开始查找资源文件所经过的路径</span><br><span class="line">-包括网络资源&amp;本地资源（如：E:\mmper\练习\img\flower.jpg）</span><br><span class="line">（2）相对路径：从当前文件位置处开始，查找资源文件所经过的路径</span><br><span class="line">- 同目录，直接用， 直接通过资源文件名称进行引用（a.jpg）</span><br><span class="line">- 子目录，进入到子目录中，然后再对资源文件进行引用（img/a.jpg）</span><br><span class="line">- 父目录，返回到父级目录再对资源文件进行引用（../a.jpg）</span><br></pre></td></tr></table></figure><p>2.<code>&lt;a&gt;</code>:定义超链接.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">【标签】&lt;a&gt;&lt;/a&gt;</span><br><span class="line">【属性】</span><br><span class="line">href：链接地址（要跳转到的页面的地址）</span><br><span class="line">target：目标，打开新网页的形式</span><br><span class="line">取值：</span><br><span class="line">     _blank：在新标签页中打开</span><br><span class="line">     _self：在自身页面中打开（默认值）</span><br><span class="line">     _parent: 在父页面打开。如果没有父页面，此选项的行为方式相同_self。</span><br><span class="line">     _top: 在顶层页面打开</span><br><span class="line"></span><br><span class="line">title：鼠标放到链接上的提示</span><br></pre></td></tr></table></figure></p><p>3.<code>&lt;map&gt;</code>:定义图像映射。</p><p>4.<code>&lt;area&gt;</code>:定义图像地图内部的区域.</p><h3 id="6-框架标签"><a href="#6-框架标签" class="headerlink" title="6.框架标签"></a>6.框架标签</h3><p>1.<code>&lt;iframe&gt;</code>:内联框架.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">【属性】</span><br><span class="line">name:嵌入的浏览上下文（框架）的名称。该名称可以用作&lt;a&gt;标签，&lt;form&gt;标签的target属性值，或&lt;input&gt; 标签和 &lt;button&gt;标签的formtaget属性值。</span><br><span class="line">src:嵌套页面的URL地址。</span><br></pre></td></tr></table></figure><h3 id="7-格式标签"><a href="#7-格式标签" class="headerlink" title="7.格式标签"></a>7.格式标签</h3><p>1.<code>&lt;h1&gt;-&lt;h6&gt;</code>:定义 HTML 标题.</p><p>2.<code>&lt;p&gt;</code>:定义段落.</p><p>3.<code>&lt;br&gt;</code>:定义换行.</p><p>4.<code>&lt;hr&gt;</code>:定义水平线.</p><p>5.<code>&lt;em&gt;</code>:定义强调文本.</p><p>6.<code>&lt;strong&gt;</code>:定义语气更为强烈的强调文本.</p><p>7.<code>&lt;sup&gt;</code>:定义上标文本.</p><p>8.<code>&lt;sub&gt;</code>:定义下标文本.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;HTML常用标签&quot;&gt;&lt;a href=&quot;#HTML常用标签&quot; class=&quot;headerlink&quot; title=&quot;HTML常用标签&quot;&gt;&lt;/a&gt;HTML常用标签&lt;/h2&gt;&lt;h3 id=&quot;1-布局标签-amp-语义化&quot;&gt;&lt;a href=&quot;#1-布局标签-amp-语义化&quot;
      
    
    </summary>
    
      <category term="Web前端" scheme="http://blogliu.com.cn/categories/Web%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="http://blogliu.com.cn/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="标签" scheme="http://blogliu.com.cn/tags/%E6%A0%87%E7%AD%BE/"/>
    
  </entry>
  
  <entry>
    <title>HTML的空元素和可替换元素</title>
    <link href="http://blogliu.com.cn/posts/b0da0b6d/"/>
    <id>http://blogliu.com.cn/posts/b0da0b6d/</id>
    <published>2018-11-24T13:50:54.000Z</published>
    <updated>2018-11-24T14:55:41.403Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element" target="_blank" rel="noopener">HTML所有元素参考</a></p><h2 id="空元素"><a href="#空元素" class="headerlink" title="空元素"></a>空元素</h2><ul><li><p>什么是HTML 元素？</p><p> HTML元素指的是从开始标签（start tag）到结束标签（end tag）的所有代码。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;tagname&gt; Content goes here...&lt;/tagname&gt;</span><br></pre></td></tr></table></figure><p>比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;我的第一个段落&lt;/p&gt;</span><br><span class="line">&lt;h1&gt;我的第一行代码&lt;/h1&gt;</span><br></pre></td></tr></table></figure></p><ul><li><p>什么是空标签？</p><p>  当一个HTML元素没有内容的时候就叫做空元素。一个空元素没有结束标签（end tag），比如<code>&lt;br&gt;</code>  这样的。</p></li></ul><ul><li>所有的空元素列表：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;area&gt;</span><br><span class="line">&lt;base&gt;</span><br><span class="line">&lt;br&gt;</span><br><span class="line">&lt;col&gt;</span><br><span class="line">&lt;embed&gt;</span><br><span class="line">&lt;hr&gt;</span><br><span class="line">&lt;img&gt;</span><br><span class="line">&lt;input&gt;</span><br><span class="line">&lt;keyen&gt; (HTML 5.2 Draft removed)</span><br><span class="line">&lt;link&gt;</span><br><span class="line">&lt;meta&gt;</span><br><span class="line">&lt;param&gt;</span><br><span class="line">&lt;source&gt;</span><br><span class="line">&lt;track&gt;</span><br><span class="line">&lt;wbr&gt;</span><br><span class="line">&lt;colgroup&gt; (当有span时，是空标签)</span><br></pre></td></tr></table></figure><h2 id="可替换元素"><a href="#可替换元素" class="headerlink" title="可替换元素"></a>可替换元素</h2><p>可替换元素是浏览器根据其标签的元素和属性来判断显示具体的内容。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;ss.png&quot; alt=&quot;this is ss&quot;&gt;</span><br></pre></td></tr></table></figure></p><p>这是一个img元素，当src换一个的时候，浏览器显示内容就不一样。<br>HTML中的 <code>&lt;img&gt;、&lt;input&gt;、&lt;textarea&gt;、&lt;select&gt;、&lt;object&gt;</code>  等都是可替换元素。但HTML中大多数元素是不可替换元素。</p><h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><p><a href="https://www.w3schools.com" target="_blank" rel="noopener">W3C</a></p><p>万维网联盟（World Wide Web Consortium，W3C），又称W3C理事会，是万维网的主要国际标准组织[2]。为半自治非政府组织（quasi-autonomous non-governmental organisation）。</p><p>万维网联盟（W3C）由蒂姆·伯纳斯-李于1994年10月离开欧洲核子研究中心（CERN）后成立，在欧盟执委会和国防高等研究计划署（DARPA）的支持下成立于麻省理工学院MIT计算器科学与人工智能实验室（MIT／LCS）[2]，DARPA曾率先推出了互联网及其前身ARPANET。</p><p>该组织试图透过W3C制定的新标准来促进业界成员间的兼容性和协议。不兼容的HTML版本由不同的供应商提供，导致网页显示方式不一致。联盟试图让所有的供应商实施一套由联盟选择的核心原则和组件。</p><p>为解决网络应用中不同平台、技术和开发者带来的不兼容问题，保障网络信息的顺利和完整流通，万维网联盟制定了一系列标准并督促网络应用开发者和内容提供者遵循这些标准。标准的内容包括使用语言的规范，开发中使用的导则和解释引擎的行为等等。W3C也制定了包括XML和CSS等的众多影响深远的标准规范。</p><p>但是，W3C制定的网络标准似乎并非强制，而只是推荐标准。因此部分网站仍然不能完全实现这些标准，特别是使用早期所见即所得网页编辑软件设计的网页往往会包含大量非标准代码。</p><p><a href="https://developer.mozilla.org/zh-CN/" target="_blank" rel="noopener">MDN</a></p><p>MDN Web Docs（旧称Mozilla Developer Network、Mozilla Developer Center，简称MDN）是一个汇集众多Mozilla基金会产品和网络技术开发文档的免费网站[1]。</p><p>该项目始于2005年，最初由Mozilla公司员工Deb Richardson领导。自2006年以来，文档工作由Eric Shepherd领导[2]。</p><p>网站最初的内容是由DevEdge提供，但在AOL收购Netscape后，DevEdge网站也宣布关闭。为此Mozilla基金会向AOL获取了DevEdge发布的内容[3][2]，同时将DevEdge内容搬移到mozilla.org[4][5]。</p><p>MDN本身有一个论坛，并在Mozilla IRC网络上有一个IRC频道#mdn。MDN由Mozilla公司提供服务器和员工的资助。</p><p>2016年10月3日发表的Brave网页浏览器将MDN作为其搜索引擎选项之一[6]。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;HTML所有元素参考&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;空元素&quot;&gt;&lt;a hre
      
    
    </summary>
    
      <category term="Web前端" scheme="http://blogliu.com.cn/categories/Web%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="http://blogliu.com.cn/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>关于HTTP请求与响应</title>
    <link href="http://blogliu.com.cn/posts/5eb10f7/"/>
    <id>http://blogliu.com.cn/posts/5eb10f7/</id>
    <published>2018-11-24T05:15:54.000Z</published>
    <updated>2018-11-24T07:01:29.468Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-HTTP-请求"><a href="#1-HTTP-请求" class="headerlink" title="1.HTTP 请求"></a>1.HTTP 请求</h2><h3 id="什么是HTTP-请求？"><a href="#什么是HTTP-请求？" class="headerlink" title="什么是HTTP 请求？"></a>什么是HTTP 请求？</h3><p>http请求是一台电脑为了和另一台电脑进行交流而发送的一个信息包。其实，他的核心就是客户端发送给服务器端的一个二进制的数据包。</p><p>一个http请求通常由以下部分组成：</p><p><strong>请求行（Request Line）、请求头（Header）、空行和请求数据（An Optional Body of the Request）四个部分组成。</strong></p><p>以Get请求为例，下图为一个Get请求的示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -s -v &quot;https://www.baidu.com&quot;</span><br></pre></td></tr></table></figure></p><p><img src="http://itimage.oss-cn-shanghai.aliyuncs.com/blogliu/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-24%20%E4%B8%8B%E5%8D%881.37.33.png" alt="Get请求图片"></p><h4 id="第一部分：请求行，用来说明请求类型，要访问的资源以及所使用的HTTP协议版本。"><a href="#第一部分：请求行，用来说明请求类型，要访问的资源以及所使用的HTTP协议版本。" class="headerlink" title="第一部分：请求行，用来说明请求类型，要访问的资源以及所使用的HTTP协议版本。"></a>第一部分：请求行，用来说明请求类型，要访问的资源以及所使用的HTTP协议版本。</h4><p>GET说明请求类型为GET， HTTP/1.1 说明使用的是HTTP1.1版本。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">HTTP1.0定义了三种请求方法：GET POST HEAD</span><br><span class="line">HTTP1.1新增了五种请求方法：OPTIONS PUT DELETE TRACE CONNECT</span><br><span class="line"></span><br><span class="line">GET 请求指定页面信息，并返回实体主体。</span><br><span class="line">POST 多用于提交表单或者上传文件，数据包含在请求体中。</span><br><span class="line">PUT 从客户端向服务器传送的数据取代指定的文档的内容。</span><br><span class="line">DELETE 请求服务器删除指定的页面。</span><br><span class="line">CONNNECT http1.1协议中预留给能够将连接改为管道方式的代理服务器。</span><br><span class="line">OPTIONS 允许客户端查看服务器的性能。</span><br><span class="line">TRACE 回显服务器收到的请求，主要用于测试或者诊断。</span><br><span class="line">HEAD 类似于GET请求，只不过返回响应中没有具体的内容，用于获取报头。</span><br></pre></td></tr></table></figure><h4 id="第二部分：请求头，用来说明服务器要使用的附加信息"><a href="#第二部分：请求头，用来说明服务器要使用的附加信息" class="headerlink" title="第二部分：请求头，用来说明服务器要使用的附加信息"></a>第二部分：请求头，用来说明服务器要使用的附加信息</h4><ul><li>Host指出请求的目的地。</li><li>User-Agent 客户端发起请求的途径</li><li>Accept 客户端希望接收的数据类型</li></ul><h4 id="第三部分：空行-请求头后面的空行是必须的。"><a href="#第三部分：空行-请求头后面的空行是必须的。" class="headerlink" title="第三部分：空行 请求头后面的空行是必须的。"></a>第三部分：空行 请求头后面的空行是必须的。</h4><p>即使第四部分的请求数据为空，也必须有空行。</p><h4 id="第四部分：请求数据也叫请求体。可以添加任意的其他数据。可为空"><a href="#第四部分：请求数据也叫请求体。可以添加任意的其他数据。可为空" class="headerlink" title="第四部分：请求数据也叫请求体。可以添加任意的其他数据。可为空"></a>第四部分：请求数据也叫请求体。可以添加任意的其他数据。可为空</h4><h2 id="2-HTTP响应"><a href="#2-HTTP响应" class="headerlink" title="2.HTTP响应"></a>2.HTTP响应</h2><h3 id="什么是HTTP响应？"><a href="#什么是HTTP响应？" class="headerlink" title="什么是HTTP响应？"></a>什么是HTTP响应？</h3><p>http响应是服务端为了响应客户端之前发的请求而发送给客户端的一个数据包。他包含了客户端要求的信息。比如，当你向一个天气查询的服务器发送有关天气情况的请求时，服务器就会返回给你相关的天气信息。</p><p>一个http响应通常由以下部分组成：</p><p><strong>状态行(Status Line) 、消息报头(Headers)、空行、和响应正文。</strong></p><p>以刚才的请求为例，下图为服务器返回信息。</p><p><img src="http://itimage.oss-cn-shanghai.aliyuncs.com/blogliu/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-24%20%E4%B8%8B%E5%8D%882.03.43.png" alt="Get响应图片"></p><h4 id="第一部分：状态行，由HTTP协议版本号，状态码，状态消息-三部分组成。"><a href="#第一部分：状态行，由HTTP协议版本号，状态码，状态消息-三部分组成。" class="headerlink" title="第一部分：状态行，由HTTP协议版本号，状态码，状态消息 三部分组成。"></a>第一部分：状态行，由HTTP协议版本号，状态码，状态消息 三部分组成。</h4><h4 id="第二部分：消息报头，用来说明客户端要使用的一些附加信息"><a href="#第二部分：消息报头，用来说明客户端要使用的一些附加信息" class="headerlink" title="第二部分：消息报头，用来说明客户端要使用的一些附加信息"></a>第二部分：消息报头，用来说明客户端要使用的一些附加信息</h4><ul><li>Server服务器类型</li><li>Date 生成响应的日期和时间。</li><li>Content-Type:指定了MIME类型的HTML</li></ul><h4 id="第三部分：空行，消息报头后面的空行是必须的。"><a href="#第三部分：空行，消息报头后面的空行是必须的。" class="headerlink" title="第三部分：空行，消息报头后面的空行是必须的。"></a>第三部分：空行，消息报头后面的空行是必须的。</h4><h4 id="第四部分：响应正文，服务器返回给客户端的文本消息。"><a href="#第四部分：响应正文，服务器返回给客户端的文本消息。" class="headerlink" title="第四部分：响应正文，服务器返回给客户端的文本消息。"></a>第四部分：响应正文，服务器返回给客户端的文本消息。</h4><p>空行后面的html部分为响应正文。</p><h2 id="3-善用Chrome开发者工具"><a href="#3-善用Chrome开发者工具" class="headerlink" title="3.善用Chrome开发者工具"></a>3.善用Chrome开发者工具</h2><p>利用Chrome浏览器可以很方便查看我们浏览网页相关的请求与响应。在浏览器中鼠标右键，然后点击检查就可以打开控制台。</p><p><img src="http://itimage.oss-cn-shanghai.aliyuncs.com/blogliu/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-24%20%E4%B8%8B%E5%8D%882.23.25.png" alt="控制台"></p><ul><li><p>利用工具查看请求<br><img src="http://itimage.oss-cn-shanghai.aliyuncs.com/blogliu/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-24%20%E4%B8%8B%E5%8D%882.25.31.png" alt="查看请求"></p></li><li><p>利用工具查看响应<br><img src="http://itimage.oss-cn-shanghai.aliyuncs.com/blogliu/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-24%20%E4%B8%8B%E5%8D%882.28.27.png" alt="查看响应"></p></li></ul><h2 id="4-如何使用curl命令"><a href="#4-如何使用curl命令" class="headerlink" title="4.如何使用curl命令"></a>4.如何使用curl命令</h2><p>curl 全称 CommandLine URL ,是在命令行下工作，利用URL的语法进行数据的传输或者文件的传输。多用于Unix和Linux系统，开源工具，功能十分强大。</p><h3 id="curl用法，只介绍一般用法，详细用法参阅官网。"><a href="#curl用法，只介绍一般用法，详细用法参阅官网。" class="headerlink" title="curl用法，只介绍一般用法，详细用法参阅官网。"></a>curl用法，只介绍一般用法，详细用法参阅<a href="https://curl.haxx.se/" target="_blank" rel="noopener">官网</a>。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -[选项][URL]</span><br></pre></td></tr></table></figure><ul><li><p>-v 选项，指定该选项后，可跟踪URL的连接信息，返回信息包含很多重要信息：1.域名解释过程。2请求头信息。3回应头信息。</p></li><li><p>-u 选项，带用户验证的连接。可以访问或获取用户验证的URL。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -u username:password https://127.0.0.1/</span><br></pre></td></tr></table></figure></li><li><p>-d选项，带请求参数的连接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -d &apos;user=liuteng&amp;age=18&apos; http://xxxx/</span><br></pre></td></tr></table></figure></li><li><p>-X选项，指定请求方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -XGET www.baidu.com</span><br></pre></td></tr></table></figure></li></ul><p>curl还有很多实用实用的功能，后续用法持续更新。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-HTTP-请求&quot;&gt;&lt;a href=&quot;#1-HTTP-请求&quot; class=&quot;headerlink&quot; title=&quot;1.HTTP 请求&quot;&gt;&lt;/a&gt;1.HTTP 请求&lt;/h2&gt;&lt;h3 id=&quot;什么是HTTP-请求？&quot;&gt;&lt;a href=&quot;#什么是HTTP-请求？&quot;
      
    
    </summary>
    
      <category term="Web前端" scheme="http://blogliu.com.cn/categories/Web%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="http://blogliu.com.cn/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="HTTP" scheme="http://blogliu.com.cn/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>Android群英传读书笔记系列（二）</title>
    <link href="http://blogliu.com.cn/posts/cddb9e34/"/>
    <id>http://blogliu.com.cn/posts/cddb9e34/</id>
    <published>2017-01-18T07:29:23.000Z</published>
    <updated>2018-11-23T08:40:17.400Z</updated>
    
    <content type="html"><![CDATA[<p>Android群英传读书笔记记录，备忘，关于一些知识点以及重要的地方。</p><h2 id="1-Android-Scroll分析"><a href="#1-Android-Scroll分析" class="headerlink" title="1. Android Scroll分析"></a>1. Android Scroll分析</h2><p>关键词：绝对坐标与视图坐标的区别</p><h3 id="1-1-Android坐标系"><a href="#1-1-Android坐标系" class="headerlink" title="1.1. Android坐标系"></a>1.1. Android坐标系</h3><p>在Android中，是以屏幕的左上角作为坐标系的原点，向右是x轴，向下是Y轴。</p><p>系统提供了getLocationOnScreen(int locaiton[]) 获取坐标系位置，另外触控事件中getRawX()  ,getRawY()获取的同样是Android坐标系中的坐标。</p><h3 id="1-2-视图坐标系"><a href="#1-2-视图坐标系" class="headerlink" title="1.2 视图坐标系"></a>1.2 视图坐标系</h3><p>关于方向与1.1坐标系是一致的，只不过视图坐标系中，一个view的原点是以父视图坐上角为坐标原点。触控事件中getX()  getY() 得到的就是视图坐标系中的坐标。</p><h3 id="1-3-触控事件——MotionEvent"><a href="#1-3-触控事件——MotionEvent" class="headerlink" title="1.3 触控事件——MotionEvent"></a>1.3 触控事件——MotionEvent</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单点触摸按下动作</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ACTION_DOWN=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//单点触摸离开动作</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ACTION_UP=<span class="number">1</span>;</span><br><span class="line"><span class="comment">//触摸点移动动作</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ACTION_MOVE=<span class="number">2</span>;</span><br><span class="line"><span class="comment">//触摸点取消动作</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ACTION_CACEL=<span class="number">3</span>;</span><br><span class="line"><span class="comment">//触摸动作超出边界</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ACTION_OUTSIDE=<span class="number">4</span>;</span><br><span class="line"><span class="comment">//多点触摸按下动作</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ACTION_POINTER_DOWN=<span class="number">5</span>;</span><br><span class="line"><span class="comment">//多点离开动作</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ACTION_POINTER_UP=<span class="number">6</span>;</span><br></pre></td></tr></table></figure><h3 id="1-4-实现滑动的七种方法"><a href="#1-4-实现滑动的七种方法" class="headerlink" title="1.4 实现滑动的七种方法"></a>1.4 实现滑动的七种方法</h3><h4 id="1-4-1-layout-方法"><a href="#1-4-1-layout-方法" class="headerlink" title="1.4.1 layout()方法"></a>1.4.1 layout()方法</h4><p>onTouchEvent()计算滑动距离，不断layout()，让view跟随手指滑动。</p><h4 id="1-4-2-offsetLeftAndrRight-和offsetTopAndrBottom"><a href="#1-4-2-offsetLeftAndrRight-和offsetTopAndrBottom" class="headerlink" title="1.4.2 offsetLeftAndrRight()和offsetTopAndrBottom()"></a>1.4.2 offsetLeftAndrRight()和offsetTopAndrBottom()</h4><p>系统提供的对上下、左右移动的封装，参数为偏移量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//同时对left和right进行偏移</span></span><br><span class="line">offsetLeftAndrRight(offsetX)</span><br><span class="line"><span class="comment">//同时对top和bottom进行偏移</span></span><br><span class="line">offsetTopAndrBotton(offsetY)</span><br></pre></td></tr></table></figure><h4 id="1-4-3-LayoutParams"><a href="#1-4-3-LayoutParams" class="headerlink" title="1.4.3 LayoutParams"></a>1.4.3 LayoutParams</h4><p>LayoutParams保存了一个view的参数，通过getLayoutParams()获取，然后进行修改</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LinearLayout.LayoutParams layoutParams=(LinearLayout.LayoutParams)getLayoutParams();</span><br><span class="line">layoutParams.leftMargin=getLeft()+offsetX;</span><br><span class="line">layoutParams.topMargin=getTop()+offsetY;</span><br><span class="line">setLayoutParams(layoutParams);</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ViewGroup.MarginLayoutParms layoutParams=(ViewGroup.MarginLayoutParams)getLayoutParms();</span><br><span class="line">layoutParms.leftMargin=getLeft()+offsetX();</span><br><span class="line">layoutParms.topMargin=getTop()+offsetY();</span><br><span class="line">setLayoutParams(layoutParms);</span><br></pre></td></tr></table></figure><h4 id="1-4-4-scrollTo与scrollBy"><a href="#1-4-4-scrollTo与scrollBy" class="headerlink" title="1.4.4 scrollTo与scrollBy"></a>1.4.4 scrollTo与scrollBy</h4><p>scrollTo移动到某个位置，scrollBy移动某个增量。</p><p>关键点：viewgroup中 移动的是子view,view中，移动的是view中的内容。</p><p>移动方向问题，反向移动，可以理解为：view未动，移动的是屏幕</p><h4 id="1-4-5-Scroller"><a href="#1-4-5-Scroller" class="headerlink" title="1.4.5 Scroller"></a>1.4.5 Scroller</h4><p>实现平滑滚动</p><p>三个步骤：</p><ul><li>初始化Scroller</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化Scroller</span></span><br><span class="line">mScroller=<span class="keyword">new</span> Scroller(context);</span><br></pre></td></tr></table></figure><ul><li>重写computeScroll()方法，实现模拟滑动</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">computeScroll</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">super</span>.computeScroll();</span><br><span class="line"><span class="comment">//判断Scroller是否执行完毕</span></span><br><span class="line"><span class="keyword">if</span>(mScroller.computeScrollOffset())&#123;</span><br><span class="line">((View)getParent()).scrollTo(mScroller.getCurrX(),mScroller.getCurrY());</span><br><span class="line"><span class="comment">//通过重绘不断调用computeScroll</span></span><br><span class="line">invalidate();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>startScroll 开启模拟过程</li></ul><h4 id="1-4-6-属性动画"><a href="#1-4-6-属性动画" class="headerlink" title="1.4.6 属性动画"></a>1.4.6 属性动画</h4><h4 id="1-4-7-ViewDragHelper"><a href="#1-4-7-ViewDragHelper" class="headerlink" title="1.4.7 ViewDragHelper"></a>1.4.7 ViewDragHelper</h4><ul><li>初始化ViewDragHelper</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mViewDragHelper=ViewDragHelper.create(<span class="keyword">this</span>,callback);</span><br></pre></td></tr></table></figure><ul><li>拦截事件</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span><span class="params">(MotionEvent ev)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> mViewDragHelper.shouldInterceptTouchEvent(ev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span></span>&#123;</span><br><span class="line"><span class="comment">//将触摸事件传递给ViewDragHelper,此操作必不可少</span></span><br><span class="line">mViewDragHelper.processTouchEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>处理computeScroll()</li></ul><p>模板写法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">computeScroll</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(mViewDragHelper.continueSetting(<span class="keyword">true</span>))&#123;</span><br><span class="line">ViewCompat.postInvalidateOnAnimation(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>处理回调Callback</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ViewDragHelper.Callback callback=<span class="keyword">new</span> ViewDragHelper.Callback()&#123;</span><br><span class="line"><span class="meta">@Overrride</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryCaptureView</span><span class="params">(View child,<span class="keyword">int</span> pointerId)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">//根据具体需求修改</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>滑动方法</p><p>clampViewPositionVertical()</p><p>clampViewPositionHorizontal()</p><h2 id="2-Android-绘图机制与处理技巧"><a href="#2-Android-绘图机制与处理技巧" class="headerlink" title="2.Android 绘图机制与处理技巧"></a>2.Android 绘图机制与处理技巧</h2><h3 id="2-1屏幕的尺寸信息"><a href="#2-1屏幕的尺寸信息" class="headerlink" title="2.1屏幕的尺寸信息"></a>2.1屏幕的尺寸信息</h3><h4 id="2-1-1-屏幕参数"><a href="#2-1-1-屏幕参数" class="headerlink" title="2.1.1 屏幕参数"></a>2.1.1 屏幕参数</h4><ul><li>屏幕大小</li></ul><p>对角线长度</p><ul><li>分辨率</li></ul><p>手机屏幕像素点个数</p><ul><li>PPI </li></ul><p>Android使用mdpi(密度值为160)的屏幕作为标准，在这个屏幕上1px=1dp.其他屏幕按比例换算。</p><p>mdpi 1dp=1px</p><p>hdpi 1dp=1.5px</p><p>xhdpi 1dp=2px</p><p>xxhdpi 1dp=3px</p><h3 id="2-2-2D绘图基础"><a href="#2-2-2D绘图基础" class="headerlink" title="2.2 2D绘图基础"></a>2.2 2D绘图基础</h3><p>paint属性</p><ul><li>setAntiAlias()  //设置画笔的锯齿效果</li><li>setColor()   //设置画笔的颜色</li><li>setARGB()  //设置画笔的ARGB值</li><li>setAlpha()  //设置画笔的Alpha值</li><li>setTextSize()  //设置字体的尺寸</li><li>setStyle()   //设置画笔的风格</li><li>setStrokeWidth()  //设置空心边框的宽度</li></ul><h4 id="2-2-1-canvas-绘图API"><a href="#2-2-1-canvas-绘图API" class="headerlink" title="2.2.1 canvas 绘图API"></a>2.2.1 canvas 绘图API</h4><ul><li>DrawPonit 绘制点</li></ul><p>canvas.drawPoint(x,y,paint)</p><ul><li>DrawLine 绘制直线</li></ul><p>canvas.drawLine(startX,startY,endX,endY,paint)</p><ul><li>DrawLines 绘制多条直线</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">floast[] pts=&#123;startX1,startY1,endX1,endY1,...&#125;</span><br><span class="line">canvas.drawLines(pts,ponit)</span><br></pre></td></tr></table></figure><ul><li>DrawRect 绘制矩形</li></ul><p>canvas.drawRect(left,top,right,bottom,paint)</p><ul><li>DrawRoundRect 绘制圆角矩形</li></ul><p>canvas.drawRoundRect(left,top,bottom,raidusX,radiuxY,paint)</p><ul><li>DrawCircle 绘制圆</li></ul><p>canvas.drawCircle(circleX,circleY,radius,paint)</p><ul><li>DrawArc 绘制弧形，扇形</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">paint.setStyle(Paint.Style.STROKE);</span><br><span class="line">canvas.drawArc(left,top,right,bottom,startAngle,sweepAngle,userCenter,paint)</span><br></pre></td></tr></table></figure><ul><li>DarwOval 绘制椭圆</li></ul><p>canvas.drawOval(left,top,right,bottom,paint)</p><ul><li>DrawText 绘制文本</li></ul><p>canvas.drawText(text,startX,startY,paint)</p><ul><li>DrawPosText 在指定位置绘制文本</li></ul><p>canvas.drawPosText(text,new float[]{X1,Y1,X2,Y2,…Xn,Yn})</p><ul><li>DrawPath 绘制路径</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Path path=<span class="keyword">new</span> Path();</span><br><span class="line">path.moveTo(<span class="number">50</span>,<span class="number">50</span>);</span><br><span class="line">path.lineTo(<span class="number">100</span>,<span class="number">100</span>);</span><br><span class="line">path.lineTo(<span class="number">100</span>,<span class="number">300</span>);</span><br><span class="line">path.lineTo(<span class="number">300</span>,<span class="number">50</span>);</span><br><span class="line">canvas.drawPath(path,paint);</span><br></pre></td></tr></table></figure><h3 id="2-3-Android-Xml绘图"><a href="#2-3-Android-Xml绘图" class="headerlink" title="2.3 Android Xml绘图"></a>2.3 Android Xml绘图</h3><h4 id="2-3-1-bitmap"><a href="#2-3-1-bitmap" class="headerlink" title="2.3.1 bitmap"></a>2.3.1 bitmap</h4><p>src引用</p><h4 id="2-3-2-Shape"><a href="#2-3-2-Shape" class="headerlink" title="2.3.2 Shape"></a>2.3.2 Shape</h4><p>注意：shape支持的参数</p><h4 id="2-3-3-Layer"><a href="#2-3-3-Layer" class="headerlink" title="2.3.3 Layer"></a>2.3.3 Layer</h4><p>图层示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"&gt;</span></span><br><span class="line"><span class="meta">&lt;layer-list xmlns:android="http://schemas.android.com/apk/res/android"&gt;</span></span><br><span class="line"><span class="meta">&lt;item android:drawable="@drawable/ic_launcher"/&gt;</span></span><br><span class="line"><span class="meta">&lt;item android:drawable="@drawable/ic_launcher"</span></span><br><span class="line"><span class="meta">android:left="10.0dip"</span></span><br><span class="line"><span class="meta">android:top="10.0dip"</span></span><br><span class="line"><span class="meta">android:right="10.0dip"</span></span><br><span class="line"><span class="meta">android:bottom="10.0dip"/&gt;</span></span><br><span class="line"><span class="meta">&lt;/layer-list&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-3-4-selector"><a href="#2-3-4-selector" class="headerlink" title="2.3.4 selector"></a>2.3.4 selector</h4><p>主要实现不同效果</p><p>selector中可以组合使用shape</p><h3 id="2-4-Android-绘图技巧"><a href="#2-4-Android-绘图技巧" class="headerlink" title="2.4 Android 绘图技巧"></a>2.4 Android 绘图技巧</h3><h4 id="2-4-1-canvas"><a href="#2-4-1-canvas" class="headerlink" title="2.4.1 canvas"></a>2.4.1 canvas</h4><p>Canvas，几个非常有用的方法</p><ul><li>Canvas.save()</li><li>Canvas.restore()</li><li>Canvas.translate()</li><li>Canvas.rotate()</li></ul><p>save 保存画布，让后续操作就像在一个新的图层上操作一样</p><p>restore  合并图层，save之后的所有图像与save之前的图像合并</p><p>translate  坐标系的平移</p><p>rotate  也可以理解为坐标系的翻转</p><p>可以利用rotate画布的旋转和translate坐标系的平移实现一些复杂的效果</p><h4 id="2-4-2-Layer图层"><a href="#2-4-2-Layer图层" class="headerlink" title="2.4.2 Layer图层"></a>2.4.2 Layer图层</h4><p>通过saveLayer()方法  saveLayerAlpha()方法将一个图层入栈，使用restore()方法  restoreToCount()方法将一个图层出栈。</p><p>出栈的时候，会把图像绘制到上层Canvas上。</p><h3 id="2-5-Android-图像处理之色彩特效处理"><a href="#2-5-Android-图像处理之色彩特效处理" class="headerlink" title="2.5 Android 图像处理之色彩特效处理"></a>2.5 Android 图像处理之色彩特效处理</h3><h4 id="2-5-1-色彩矩阵分析"><a href="#2-5-1-色彩矩阵分析" class="headerlink" title="2.5.1 色彩矩阵分析"></a>2.5.1 色彩矩阵分析</h4><ul><li>色调–物体传播的颜色</li><li>饱和度–颜色的纯度  从0到100%</li><li>亮度–颜色的相对明暗程度</li></ul><p>颜色矩阵  ColorMatrix</p><p>这块比较复杂，专门写一篇文章，这里跳过</p><h3 id="2-6-Android图像处理之画笔特效处理"><a href="#2-6-Android图像处理之画笔特效处理" class="headerlink" title="2.6 Android图像处理之画笔特效处理"></a>2.6 Android图像处理之画笔特效处理</h3><h4 id="2-6-1-PorterDuffXfermode"><a href="#2-6-1-PorterDuffXfermode" class="headerlink" title="2.6.1 PorterDuffXfermode"></a>2.6.1 PorterDuffXfermode</h4><p>控制两个图像的混合显示模式</p><p>dst 是先画的图形   src是后画的图形</p><p>最常用的是通过DST_IN  SRC_IN实现将一个矩形图片变成圆角图片或者圆形图片的效果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mBitmap=BitmapFactory.decodeResouce(getResources(),R.drawable.test1);</span><br><span class="line">mOut=Bitmap.createBitamp(mBitmap.getWidth(),mBitmap.getHeight(),Bitmap.Config.ARGB_8888);</span><br><span class="line">Canvas canvas=<span class="keyword">new</span> Canvas(mOut);</span><br><span class="line">mPaint =<span class="keyword">new</span> Paint();</span><br><span class="line">mPaint.setAntiAlias(<span class="keyword">true</span>);</span><br><span class="line">canvas.drawRoundRect(<span class="number">0</span>,<span class="number">0</span>,mBitmap.getWidth(),mBitmap.getHeight(),<span class="number">80</span>,<span class="number">80</span>,mPaint);</span><br><span class="line">mPaint.setXfermode(<span class="keyword">new</span> PorterDuffXfermode(PorterDuff.Mode.SRC_IN));</span><br><span class="line"></span><br><span class="line">canvas.drawBitmap(mBitmap,<span class="number">0</span>,<span class="number">0</span>,mPaint);</span><br></pre></td></tr></table></figure><h3 id="2-7-SurfaceView"><a href="#2-7-SurfaceView" class="headerlink" title="2.7 SurfaceView"></a>2.7 SurfaceView</h3><h4 id="2-7-1-surfaceView与view"><a href="#2-7-1-surfaceView与view" class="headerlink" title="2.7.1 surfaceView与view"></a>2.7.1 surfaceView与view</h4><ul><li>view主要用于主动更新的情况下，surfaceView主要适用于被动更新，例如频繁的刷新</li><li>view在主线程中对画面进行刷新，surfaceView通过一个子线程进行页面的刷新</li><li>view在绘图时没有使用双缓冲机制，surfaceView在底层实现机制中就已经实现了双缓冲机制</li></ul><h4 id="2-7-2-创建一个surfaceview的模板"><a href="#2-7-2-创建一个surfaceview的模板" class="headerlink" title="2.7.2 创建一个surfaceview的模板"></a>2.7.2 创建一个surfaceview的模板</h4><ul><li>创建SurfaceView</li></ul><p>创建自定义的SurfaceView继承自SurfaceView,并实现两个接口-SurfaceHolder.Callback和Runnable</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SurfaceViewTemplate</span> <span class="keyword">extends</span> <span class="title">SurfaceView</span> <span class="keyword">implements</span> <span class="title">SurfaceHolder</span>.<span class="title">Callback</span>,<span class="title">Runnable</span></span></span><br></pre></td></tr></table></figure><ul><li>初始化SurfaceView</li></ul><p>在自定义surfaceview中，通常需要定义三个成员变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SurfaceHolder</span></span><br><span class="line"><span class="keyword">private</span> SurfaceHolder mHolder;</span><br><span class="line"><span class="comment">//用于绘图的Canvas</span></span><br><span class="line"><span class="keyword">private</span> Canvas mCanvas;</span><br><span class="line"><span class="comment">//子线程标志位</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> mIsDrawing;</span><br></pre></td></tr></table></figure><p>初始化方法就是对surfaceholder进行初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mHolder=getHolder();</span><br><span class="line">mHolder.addCallback(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><ul><li>使用surfaceview</li></ul><p>在surfaceCreated()方法中开启子线程进行绘制，在子线程使用一个while（mIsDrawing）的循环不停进行绘制，通过lockCanvas()方法获得的Canvas对象进行绘制，通过unlockCanvasAndPost(mCanvas)方法对画布内容进行提交。</p><p>模板代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SurfaceViewTemplate</span> <span class="keyword">extends</span> <span class="title">SurfaceView</span> <span class="keyword">implements</span> <span class="title">SurfaceHolder</span>.<span class="title">Callback</span>,<span class="title">Runnable</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> SurfaceHolder mHolder;</span><br><span class="line"><span class="keyword">private</span> Canvas mCanvas;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> mIsDrawing;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SurfaceViewTemplate</span><span class="params">(Context context)</span></span>&#123;</span><br><span class="line"><span class="keyword">super</span>(context);</span><br><span class="line">initView();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SurfaceViewTemplate</span><span class="params">(Context context,AttributeSet attrs)</span></span>&#123;</span><br><span class="line"><span class="keyword">super</span>(context,attrs);</span><br><span class="line">initView();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SurfaceViewTemplate</span><span class="params">(Context context,AttributeSet attrs,<span class="keyword">int</span> defStyle)</span></span>&#123;</span><br><span class="line"><span class="keyword">super</span>(context,attrs,defStyle);</span><br><span class="line">initView();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initView</span><span class="params">()</span></span>&#123;</span><br><span class="line">mHolder=getHolder();</span><br><span class="line">mHolder.setCallback(<span class="keyword">this</span>);</span><br><span class="line">setFocusable(<span class="keyword">true</span>);</span><br><span class="line">setFocusableInTouchMode(<span class="keyword">true</span>);</span><br><span class="line"><span class="keyword">this</span>.setKeepScreenOn(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">surfaceCreate</span><span class="params">(SurfaceHolder holder)</span></span>&#123;</span><br><span class="line">mIdDrawing=<span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">this</span>).start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">surfaceChanged</span><span class="params">(SurfaceHolder holder,<span class="keyword">int</span> format, <span class="keyword">int</span> width,<span class="keyword">int</span> height)</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">surfaceDestroyed</span><span class="params">(SurfaceHolder holder)</span></span>&#123;</span><br><span class="line">mIdDrawing=<span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(mIdDrawing)&#123;</span><br><span class="line">draw();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">mCanvas=mHolder.lockCanvas();</span><br><span class="line"><span class="comment">//draw something</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">&#125; <span class="keyword">finally</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(mCanvas!=<span class="keyword">null</span>)&#123;</span><br><span class="line">mHolder.unlockCanvasAndPost(mCanvas);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Android群英传读书笔记记录，备忘，关于一些知识点以及重要的地方。&lt;/p&gt;
&lt;h2 id=&quot;1-Android-Scroll分析&quot;&gt;&lt;a href=&quot;#1-Android-Scroll分析&quot; class=&quot;headerlink&quot; title=&quot;1. Android Sc
      
    
    </summary>
    
      <category term="Android" scheme="http://blogliu.com.cn/categories/Android/"/>
    
    
      <category term="读书" scheme="http://blogliu.com.cn/tags/%E8%AF%BB%E4%B9%A6/"/>
    
      <category term="笔记" scheme="http://blogliu.com.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>工作以来的一些感悟</title>
    <link href="http://blogliu.com.cn/posts/5e1364b0/"/>
    <id>http://blogliu.com.cn/posts/5e1364b0/</id>
    <published>2017-01-16T02:15:26.000Z</published>
    <updated>2018-11-23T08:40:17.395Z</updated>
    
    <content type="html"><![CDATA[<p>还是有很多感同身受的地方</p><p>原文作者：张明云</p><p>原文链接：<a href="http://zmywly8866.github.io/2016/04/05/job-experiences-in-last-years.html" target="_blank" rel="noopener">http://zmywly8866.github.io/2016/04/05/job-experiences-in-last-years.html</a></p><ul><li><p>养成良好的工作习惯（设计、代码质量、编码习惯、程序自测、版本管理等），有益于你的整个职业生涯；</p></li><li><p>迷茫的时候，做好手头上的事情；</p></li><li><p>脑力上的勤奋比体力上的勤奋重要很多倍，多思考；</p></li><li><p>危机感是让你持续前进的动力；</p></li><li><p>不能只靠经验去解决问题，要尽早形成一套属于自己的解决问题的方法；</p></li><li><p>不能为了快而牺牲质量，没搞定的事情迟早需要搞定，没弄明白的东西迟早需要弄明白，还不如一次性搞定；</p></li><li><p>最能提高工作效率的方式是工作不要返工；</p></li><li><p>生病了就要治，不要硬抗；</p></li><li><p>尽早考驾照，至于原因：你这辈子肯定会买车和买房吧；</p></li><li><p>不要为了省钱而降低生活质量，比如买二手物品、便宜的手机等，这些东西会给你带来持续的烦恼（就拿便宜的手机来讲：耗电、信号差、容易出问题，任何一件事情都能烦死你），会大大降低你的生活质量；</p></li><li><p>自信很重要，有了自信工作中没有什么问题是解决不了的；</p></li><li><p>学习的最好方式，是将自己的理解表达出来，可以是写作，也可以是帮助他人解决问题；</p></li><li><p>如果一件事情你花一个小时还没有思路，应该考虑寻求帮助，比如问同事、在社区中找答案、或者通过搜索引擎来解决；</p></li><li><p>搜索引擎尽量使用谷歌，至于原因：你用了就知道了；</p></li><li><p>书一定要看，书中的内容成体系，能够扩展你的视野，如果是要深入某一个知识点，阅读技术博客和源码更有价值；</p></li><li><p>有现成的轮子，就没必要再造一个同样的轮子，能用开源项目的尽量用开源项目；</p></li><li><p>网上的很多观点只能作为参考，不要过于迷信，有很多信息都只是告诉你结果，不会告诉你原因，或者有些结果是和环境有关的（比如不同API版本的AsyncTask实现原理不一样）；还有只说优点不说缺点（比如Chrome插件多、体验好，但占内存；Genymotion确实快，但不支持arm架构的so等）；所以很多东西需要自己实践之后才能得出结论，不然随意发表观点只会被别人笑话；</p></li><li><p>过早的优化是万恶之源；</p></li><li><p>工作忙的时候容易有情绪，此种情况下不要随意发表观点，甚至少说话，不然事后你多半会后悔；</p></li><li><p>出色的工作是在工作中有创造性，而不仅仅是一个执行者，简单来讲就是工作不仅仅要做完，还要做好，但做好很难；</p></li><li><p>不要为了哪门语言好、哪个工具棒去和别人争论，真的是浪费时间；</p></li><li><p>你必须承认人与人之间确实存在差距，横向比较可以是动力，但不能因此有负面情绪，没有意义；</p></li><li><p>作为团队的leader，想方设法发挥团队最大的价值，不要任何事情都亲力亲为，你的工作内容是给大家解决问题，想方设法提高大家的工作效率（比如持续集成、体力工作自动化、找趁手的工具、优化流程等）；</p></li><li><p>不到万不得已，不要因为工作做不完而去招人，工作是永远忙不完的，应该是根据团队的短板去招对应的人（差哪方面的人才就找哪方面的人才）；</p></li><li><p>评估工作量的时候，给出的时间至少是心里预期的2倍以上，不然最终坑的还是自己；</p></li><li><p>工作上并不是任何事情都需要通过技术手段来解决，技术投入大的可以和产品沟通，在能够达到同样效果的前提下，优化产品的交互。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;还是有很多感同身受的地方&lt;/p&gt;
&lt;p&gt;原文作者：张明云&lt;/p&gt;
&lt;p&gt;原文链接：&lt;a href=&quot;http://zmywly8866.github.io/2016/04/05/job-experiences-in-last-years.html&quot; target=&quot;_bla
      
    
    </summary>
    
      <category term="Android" scheme="http://blogliu.com.cn/categories/Android/"/>
    
    
      <category term="生活" scheme="http://blogliu.com.cn/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="随笔" scheme="http://blogliu.com.cn/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>Android群英传读书笔记系列（一）</title>
    <link href="http://blogliu.com.cn/posts/fdcd72ec/"/>
    <id>http://blogliu.com.cn/posts/fdcd72ec/</id>
    <published>2017-01-15T01:33:41.000Z</published>
    <updated>2018-11-23T08:40:17.387Z</updated>
    
    <content type="html"><![CDATA[<p>Android群英传读书笔记记录，备忘，关于一些知识点以及重要的地方。</p><h2 id="1-Android体系与系统架构"><a href="#1-Android体系与系统架构" class="headerlink" title="1.Android体系与系统架构"></a>1.Android体系与系统架构</h2><h3 id="1-1"><a href="#1-1" class="headerlink" title="1.1"></a>1.1</h3><p>Android体系大致分为四层：Linux内核层、库和运行时、Framework层和应用层。<br>Android的体系架构鼓励系统组件重用，共享组件间的数据，并且定义组件间的访问权限控制。可以说这些层次结构既是相互独立，又是相互关联的。</p><h4 id="1-1-1-Linux层"><a href="#1-1-1-Linux层" class="headerlink" title="1.1.1 Linux层"></a>1.1.1 Linux层</h4><p>Linux层包含系统的核心服务，包括硬件驱动，进程管理，系统安全等。</p><h4 id="1-1-2-Dalvik和ART"><a href="#1-1-2-Dalvik和ART" class="headerlink" title="1.1.2 Dalvik和ART"></a>1.1.2 Dalvik和ART</h4><p>5.0之前 每个APP都会分配Dalvik，运行时编译；<br>5.0之后，ART取代了Dalvik,安装时编译，运行时就不用编译了。</p><h3 id="1-2组件架构"><a href="#1-2组件架构" class="headerlink" title="1.2组件架构"></a>1.2组件架构</h3><p>关键词：协同工作，信使Intent</p><h4 id="1-2-1-应用运行上下文对象"><a href="#1-2-1-应用运行上下文对象" class="headerlink" title="1.2.1 应用运行上下文对象"></a>1.2.1 应用运行上下文对象</h4><p>创建Context的时间点： </p><ul><li>创建Application  </li><li>创建Activity  </li><li>创建service</li></ul><h3 id="1-3-Android系统源代码目录与系统目录"><a href="#1-3-Android系统源代码目录与系统目录" class="headerlink" title="1.3 Android系统源代码目录与系统目录"></a>1.3 Android系统源代码目录与系统目录</h3><h4 id="1-3-1-系统源代码目录"><a href="#1-3-1-系统源代码目录" class="headerlink" title="1.3.1 系统源代码目录"></a>1.3.1 系统源代码目录</h4><p>可查看源码的网站：<a href="http://www.androidxref.com" target="_blank" rel="noopener">http://www.androidxref.com</a></p><h4 id="1-3-2-Android系统目录"><a href="#1-3-2-Android系统目录" class="headerlink" title="1.3.2 Android系统目录"></a>1.3.2 Android系统目录</h4><ul><li>/system/app  系统app</li><li>/system/bin  Linux自带组件</li><li>/system/build.prop 系统属性信息</li><li>/system/fonts/  系统字体</li><li>/system/framework  系统核心文件、框架层</li><li>/system/lib/  共享库（.so）</li><li>/system/media/  系统提示音，系统铃声</li><li>/system/usr/  用户的配置文件</li><li>/data/app  用户的大部分数据信息</li><li>/data/data app数据信息，报名区分</li><li>/data/system 手机的各项系统信息</li><li>/data/misc  wifi、VPN信息</li></ul><h2 id="2-Android开发工具"><a href="#2-Android开发工具" class="headerlink" title="2.Android开发工具"></a>2.Android开发工具</h2><p>关键词：Android studio<br>镜像网站：<a href="http://www.androiddevtools.cn/" target="_blank" rel="noopener">http://www.androiddevtools.cn/</a></p><h3 id="2-1-导入项目中的问题"><a href="#2-1-导入项目中的问题" class="headerlink" title="2.1 导入项目中的问题"></a>2.1 导入项目中的问题</h3><p>导入项目的gradle版本与本地不一致时，会去下载新的gradle版本，导致界面卡住。<br>解决办法：先用本地gradle创建一个新的项目，然后将项目中的gradle文件夹和build.gradle文件替换要导入项目中的对应文件夹和文件，重新编译。</p><h3 id="2-2-adb常用命令"><a href="#2-2-adb常用命令" class="headerlink" title="2.2 adb常用命令"></a>2.2 adb常用命令</h3><ul><li>adb install  安装应用</li><li>adb push  推送文件 需指定目录</li><li>adb pull  从手机获取文件</li><li>命令来源：\system\core\toolbox   和  \frameworks\base\cmds</li></ul><h2 id="3-Android控件架构和自定义控件"><a href="#3-Android控件架构和自定义控件" class="headerlink" title="3.Android控件架构和自定义控件"></a>3.Android控件架构和自定义控件</h2><p>viewGroup和view 两大类  </p><h3 id="3-1-Android界面架构图"><a href="#3-1-Android界面架构图" class="headerlink" title="3.1 Android界面架构图"></a>3.1 Android界面架构图</h3><h4 id="3-1-1-标准视图树的建立过程"><a href="#3-1-1-标准视图树的建立过程" class="headerlink" title="3.1.1 标准视图树的建立过程"></a>3.1.1 标准视图树的建立过程</h4><p>每个activity都包含一个window对象，这个对象通常是由phonewindow来实现的。phonewindow将decorview作为整个应用窗口的根view。DecorView作为窗口界面的顶层视图，封装了一些窗口操作的通常方法。<br>在显示上，它将窗口分为两部分，一个是TitleView,一个是ContentView,ContentView是一个id为content的framelayout ,activity_main.xml就是设置在这个framelayout里。</p><h3 id="3-2-View的测量"><a href="#3-2-View的测量" class="headerlink" title="3.2 View的测量"></a>3.2 View的测量</h3><p>Android通过提供MeasureSpec类，帮助我们测量view.MeasureSpec是一个32位的int值，高2位为测量的模式，低30位为测量的大小。</p><h4 id="3-2-1-测量模式"><a href="#3-2-1-测量模式" class="headerlink" title="3.2.1 测量模式"></a>3.2.1 测量模式</h4><ul><li>EXACTLY<br>—精确值模式，指定大小</li><li>AT_MOST<br>—最大值模式，wrap_content</li><li>UNSPECIFIED<br>—不指定模式，想多大多大，一般用在自定义view</li></ul><p>View默认onMeasure只支持EXACTLY模式，自定义view可以通过重写onMeasure()方法进行修改。</p><p>源码可以发现系统最终调用setMeasuredDimension()方法将测量后的宽高设置进去，所以在重写onMeasure方法时，需要将测量后的宽高值作为参数设置给setMeasureDimension()方法。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec,<span class="keyword">int</span> heightMeasureSpec)</span></span>&#123;</span><br><span class="line">setMeasuredDimension(measureWidth(widthMeasureSpec),measureHeight(heightMeasureSpec));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于measureWidth方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">measureWidth</span><span class="params">(<span class="keyword">int</span> measureSpec)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> specMode=MeasureSpec.getMode(measureSpec);</span><br><span class="line"><span class="keyword">int</span> specSize=MeasureSpec.getSize(measureSpec);</span><br><span class="line"><span class="keyword">if</span>(specMode==MeasureSpec.EXACTLY)&#123;</span><br><span class="line">result=specSize;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">result=<span class="number">200</span>;</span><br><span class="line"><span class="keyword">if</span>(specMode==MeasureSpec.AT_MOST)&#123;</span><br><span class="line">result=Math.min(result,specSize);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-View的绘制"><a href="#3-3-View的绘制" class="headerlink" title="3.3 View的绘制"></a>3.3 View的绘制</h3><p>关键词：onDraw()</p><p>对Canvas的理解：new Canvas时一般会传入一个bitmap对象，view的绘制是在bitmap上进行的绘制。</p><h3 id="3-4-自定义View"><a href="#3-4-自定义View" class="headerlink" title="3.4 自定义View"></a>3.4 自定义View</h3><p>View中比较重要的一些回调方法：</p><ul><li>onFinishInflate()  xml加载组件后回调</li><li>onSizeChanged()  组件大小改变时回调</li><li>onMeasure()  回调该方法用来测量</li><li>onLayout()  回调该方法确定显示位置</li><li>onTouchEvent()  监听到触摸事件时回调</li></ul><h4 id="3-4-1-自定义控件三种方式"><a href="#3-4-1-自定义控件三种方式" class="headerlink" title="3.4.1 自定义控件三种方式"></a>3.4.1 自定义控件三种方式</h4><ul><li>对现有控件进行扩展</li><li>通过组合实现新的控件</li><li>重写view实现全新的控件</li></ul><h4 id="3-4-2-为view添加自定义属性"><a href="#3-4-2-为view添加自定义属性" class="headerlink" title="3.4.2 为view添加自定义属性"></a>3.4.2 为view添加自定义属性</h4><p>在res资源目录的values目录下创建attrs.xml的属性定义文件（多属性的时候，在format里通过”|”区别，例:reference|color）</p><p>1.typeArray获取完值之后，要调用recycle()方法避免重新创建时的错误。</p><h4 id="3-4-3-引用ui模板"><a href="#3-4-3-引用ui模板" class="headerlink" title="3.4.3 引用ui模板"></a>3.4.3 引用ui模板</h4><p>引入自定义的命名空间<br>xmlns:custom=”<a href="http://schemes.android.com/apk/res_auto&quot;" target="_blank" rel="noopener">http://schemes.android.com/apk/res_auto&quot;</a></p><p>custom为命名空间的名字，可自定义。</p><h4 id="3-4-4-绘制圆弧"><a href="#3-4-4-绘制圆弧" class="headerlink" title="3.4.4 绘制圆弧"></a>3.4.4 绘制圆弧</h4><p>【基本语法】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawArc</span> <span class="params">(RectF oval, <span class="keyword">float</span> startAngle, <span class="keyword">float</span> sweepAngle, <span class="keyword">boolean</span> useCenter, Paint paint)</span></span></span><br></pre></td></tr></table></figure><p>参数说明</p><p>oval：圆弧所在的椭圆对象。</p><p>startAngle：圆弧的起始角度。</p><p>sweepAngle：圆弧的角度。</p><p>useCenter：是否显示半径连线，true表示显示圆弧与圆心的半径连线，false表示不显示。</p><p>paint：绘制时所使用的画笔。</p><h4 id="3-4-5-自定义ViewGroup"><a href="#3-4-5-自定义ViewGroup" class="headerlink" title="3.4.5 自定义ViewGroup"></a>3.4.5 自定义ViewGroup</h4><p>通常重写onMeasure()方法对子view进行测量，重写onLayout()方法确定子view的位置，重写onTouchEvent()方法增加响应事件。    </p><h4 id="3-4-6-事件分发"><a href="#3-4-6-事件分发" class="headerlink" title="3.4.6 事件分发"></a>3.4.6 事件分发</h4><p>关键三个方法：</p><ul><li>dispatchTouchEvent(MotionEvent ev)</li><li>onInterceptTouchEvent(MotionEvent ev)  true拦截false不拦截</li><li>onTouchEvent(MotionEvent ev)  true处理(不再往上传递)false不处理</li></ul><h2 id="4-ListView的使用技巧"><a href="#4-ListView的使用技巧" class="headerlink" title="4.ListView的使用技巧"></a>4.ListView的使用技巧</h2><p>备注:目前recycleview用的比较多</p><h3 id="4-1-使用ViewHolder模式提高效率"><a href="#4-1-使用ViewHolder模式提高效率" class="headerlink" title="4.1 使用ViewHolder模式提高效率"></a>4.1 使用ViewHolder模式提高效率</h3><p>可以提高50%以上</p><h3 id="4-2-ListView的分割线"><a href="#4-2-ListView的分割线" class="headerlink" title="4.2 ListView的分割线"></a>4.2 ListView的分割线</h3><p>android:divider</p><p>android:dividerHeight</p><p>android:divider=”@null”  可以将分割线设置成透明</p><h3 id="4-3-隐藏listview的滚动条"><a href="#4-3-隐藏listview的滚动条" class="headerlink" title="4.3 隐藏listview的滚动条"></a>4.3 隐藏listview的滚动条</h3><p>android:scrollbars=”none”</p><h3 id="4-4-取消listview的item的点击效果"><a href="#4-4-取消listview的item的点击效果" class="headerlink" title="4.4 取消listview的item的点击效果"></a>4.4 取消listview的item的点击效果</h3><p>android:listSelector=”#00000000”</p><p>或者 android:listSeletor=”@android:color/transparent”</p><h3 id="4-5-设置listview要显示在第几项"><a href="#4-5-设置listview要显示在第几项" class="headerlink" title="4.5 设置listview要显示在第几项"></a>4.5 设置listview要显示在第几项</h3><p>listView.setSelection(N); 瞬间移动完成<br>listView.smoothScrollBy(distance,duration)<br>listView.smoothScrollByOffset(offset)<br>listView.smoothScrollToPosation(index)  下面三个为平滑滚动</p><h3 id="4-6-处理空listview"><a href="#4-6-处理空listview" class="headerlink" title="4.6 处理空listview"></a>4.6 处理空listview</h3><p>ListView提供了一个方法setEmptyView(),通过这个方法可以给listview设置一个空数据下显示的默认提示</p><h3 id="4-7-listview的滑动监听"><a href="#4-7-listview的滑动监听" class="headerlink" title="4.7 listview的滑动监听"></a>4.7 listview的滑动监听</h3><ul><li>onTouchListener</li><li>onScrollListener</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Android群英传读书笔记记录，备忘，关于一些知识点以及重要的地方。&lt;/p&gt;
&lt;h2 id=&quot;1-Android体系与系统架构&quot;&gt;&lt;a href=&quot;#1-Android体系与系统架构&quot; class=&quot;headerlink&quot; title=&quot;1.Android体系与系统架构&quot;
      
    
    </summary>
    
      <category term="Android" scheme="http://blogliu.com.cn/categories/Android/"/>
    
    
      <category term="读书" scheme="http://blogliu.com.cn/tags/%E8%AF%BB%E4%B9%A6/"/>
    
      <category term="笔记" scheme="http://blogliu.com.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>轻松搞定MarkDown</title>
    <link href="http://blogliu.com.cn/posts/aebfe40d/"/>
    <id>http://blogliu.com.cn/posts/aebfe40d/</id>
    <published>2016-12-12T13:11:54.000Z</published>
    <updated>2018-11-23T08:40:17.398Z</updated>
    
    <content type="html"><![CDATA[<p>Markdown是一种轻量级的标记语言，用简单的标记语法就可以达到排版的目的，可以使我们更加专注于内容的编写，而不用过多的关注排版。本文主要整理了Markdown中常用的标记语法，便于以后查用。</p><h2 id="段落元素"><a href="#段落元素" class="headerlink" title="段落元素"></a>段落元素</h2><h3 id="1-段落与换行"><a href="#1-段落与换行" class="headerlink" title="1.段落与换行"></a>1.段落与换行</h3><p>Markdown中的段落指连续的一段文字，编写段落之间至少用一个空行隔开，段落内多个空格将被视为一个空格，段首不支持缩进。</p><p>如果想要在显示时显示多个空行，可以插入<code>&lt;br/&gt;</code>来实现,注意的是，插入的<code>&lt;br/&gt;</code>应与前后的段落中间至少空一行。</p><h3 id="2-标题"><a href="#2-标题" class="headerlink" title="2.标题"></a>2.标题</h3><p>Markdown支持两种类型的标题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//类型1</span><br><span class="line">这是一级标题</span><br><span class="line">=============</span><br><span class="line">这是二级标题</span><br><span class="line">-------------</span><br><span class="line"></span><br><span class="line">//类型2</span><br><span class="line"># 这是一级标题</span><br><span class="line">## 这是二级标题</span><br><span class="line">...</span><br><span class="line">###### 这是六级标题</span><br></pre></td></tr></table></figure><p>从上面个可以看出类型1是在标题下面插入=或者-来标识标题等级，但局限是其只能表示两个级别的标题。</p><p>类型2是在标题前面插入1-6个#，表示6个等级的标题，这是比较推荐的用法。</p><h3 id="3-引用"><a href="#3-引用" class="headerlink" title="3.引用"></a>3.引用</h3><p>Markdown中使用 &gt; 来引用。我们可以在一段文字中的每行开头加上 &gt; 来表示一段引用文字，也可以只在一段文字的开头插入一个 &gt; 来表示，如下面的1、2两种方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//方式1</span><br><span class="line">&gt; 这是一句话</span><br><span class="line">&gt; 这是第二句话</span><br><span class="line"></span><br><span class="line">//方式2</span><br><span class="line">&gt;这是一句话</span><br><span class="line">&gt;这是第二句话</span><br></pre></td></tr></table></figure><p>Markdown支持使用不同数量的 &gt; 表示嵌套引用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;这是外层的引用</span><br><span class="line">&gt;&gt;这是内层的引用</span><br></pre></td></tr></table></figure><p>效果如下:</p><blockquote><p>这是外层的引用</p><blockquote><p>这是内层的引用</p></blockquote></blockquote><h3 id="4-无序列表"><a href="#4-无序列表" class="headerlink" title="4.无序列表"></a>4.无序列表</h3><p>无序列表使用 - 、+ 或 * 来作为标记。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 第一项</span><br><span class="line">- 第二项</span><br><span class="line">- 第三项</span><br></pre></td></tr></table></figure><p>效果如下:</p><ul><li>第一项</li><li>第二项</li><li>第三项</li></ul><p>上面的-可以用+、*替换。需要注意的是，-等符号与后面的文字至少空一格空格。</p><h3 id="5-有序列表"><a href="#5-有序列表" class="headerlink" title="5.有序列表"></a>5.有序列表</h3><p>有序列表使用数字和紧挨着的点号表示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.第一项</span><br><span class="line">2.第二项</span><br><span class="line">3.第三项</span><br></pre></td></tr></table></figure><p>同无序列表一样，标记符号与后面的文字至少空一格空格。但编辑时的数字对显示无影响。</p><p>效果如下:</p><ol><li>第一项</li><li>第二项</li><li>第三项</li><li>第四项</li></ol><h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><ul><li>有序列表和无序列表的每一项中均可嵌套其他列表</li><li>在列表项之间要插入段落时，这时需要将列表项之间的段落缩进4个空格；</li><li>使用 1. 来输出 1. ；</li></ul><h3 id="6-代码区块"><a href="#6-代码区块" class="headerlink" title="6.代码区块"></a>6.代码区块</h3><p>缩进4个空格，需要注意的是，每行代码都需要至少缩进4个空格，不能像段落一样采用首行标记的偷懒写法，一个代码区会一直持续到没有缩进4个空格的那一行。</p><p>也可以用一对三个连续的 ` 来包裹代码段。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">``` Java</span><br><span class="line">System.out.println(&quot;HelloWorld&quot;);</span><br><span class="line">```</span><br></pre></td></tr></table></figure><p>效果如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">"HelloWorld"</span>);</span><br></pre></td></tr></table></figure><p>解释器可以根据代码的语言从而给代码加上语法高亮。</p><h3 id="7-分割线"><a href="#7-分割线" class="headerlink" title="7.分割线"></a>7.分割线</h3><p>使用三个及以上的*、-或_表示一个分割线，符号不能混用，符号之间可以插入多个空格。需要注意的是，使用-来插入分割线时需要与上一个段落至少空一行，否则Markdown会将上一行文字解释为二级标题。</p><h3 id="8-表格"><a href="#8-表格" class="headerlink" title="8.表格"></a>8.表格</h3><p>表格是Markdown比较复杂的一种表示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">| Table | Col1 | Col2 |</span><br><span class="line">| ----- | :---:| ----:|</span><br><span class="line">| Row1  | 1-1  | 1-2  |</span><br><span class="line">| Row2  | 2-1  | 2-2  |</span><br><span class="line">| Row3  | 3-1  | 3-2  |</span><br></pre></td></tr></table></figure><p>效果如下:</p><table><thead><tr><th>Table</th><th style="text-align:center">Col1</th><th style="text-align:right">Col2</th></tr></thead><tbody><tr><td>Row1</td><td style="text-align:center">1-1</td><td style="text-align:right">1-2</td></tr><tr><td>Row2</td><td style="text-align:center">2-1</td><td style="text-align:right">2-2</td></tr><tr><td>Row3</td><td style="text-align:center">3-1</td><td style="text-align:right">3-2</td></tr></tbody></table><p>上面第二行中的点代表对齐方式，分别是默认（居左）、居中、居右。</p><h2 id="行内元素"><a href="#行内元素" class="headerlink" title="行内元素"></a>行内元素</h2><h3 id="9-超链接"><a href="#9-超链接" class="headerlink" title="9.超链接"></a>9.超链接</h3><p>Markdown中有三种方式实现超链接。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//方式1</span><br><span class="line">[百度](http://www.baidu.com)</span><br><span class="line"></span><br><span class="line">//方式2</span><br><span class="line">[百度][Baidu-url]</span><br><span class="line">[Baidu-url]: http://www.baidu.com</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><a href="http://www.baidu.com" target="_blank" rel="noopener">百度</a></p><p>[百度][Baidu-url]<br>[Baidu-url]: <a href="http://www.baidu.com" target="_blank" rel="noopener">http://www.baidu.com</a></p><p>方式1较为常用，也可以为链接的文字加上提示文字，只要在括号中超链接加上空格后添加提示内容即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[百度](http://www.baidu.com &quot;这是提示文字&quot;)</span><br></pre></td></tr></table></figure><p>效果如下:</p><p><a href="http://www.baidu.com" title="这是提示文字" target="_blank" rel="noopener">百度</a></p><p>第三种方式是用 &lt;&gt; 来包裹URL.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//方式3</span><br><span class="line">&lt;http://www.baidu.com&gt;</span><br></pre></td></tr></table></figure><p>效果如下：<br><a href="http://www.baidu.com" target="_blank" rel="noopener">http://www.baidu.com</a></p><p>###加粗与斜体</p><p>Markdown使用*和_来表示粗体和斜体。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//加粗</span><br><span class="line">**这是加粗文字**</span><br><span class="line">__这也是加粗文字__</span><br><span class="line"></span><br><span class="line">//斜体</span><br><span class="line">*这是斜体文字*</span><br><span class="line">_这也是斜体文字_</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><strong>这是加粗文字</strong></p><p><strong>这也是加粗文字</strong></p><p><em>这是斜体文字</em></p><p><em>这也是斜体文字</em></p><p>被偶数个*或_包裹的文字显示为加粗效果，被奇数个包裹的为倾斜效果。</p><p>需要注意的是，*和_是成对出现，不能混合使用，也不能只出现一个。同时，标识符号要与标识的文字紧挨着，符号和符号之间、符号文字之间不能有任何空格。</p><h3 id="11-代码"><a href="#11-代码" class="headerlink" title="11.代码"></a>11.代码</h3><p>使用`来包裹一小段代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`Hello World`</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><code>Hello World</code></p><p>若想要在代码中添加撇号，可以使用多个撇号包裹里面需要添加的撇号，但注意里面的连续的撇号数量不能超过外面的数量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//显示一个撇号</span><br><span class="line">`` ` ``</span><br><span class="line">//显示两个撇号</span><br><span class="line">``` `` ```</span><br></pre></td></tr></table></figure><p>效果如下：</p><p>//显示一个撇号</p><p><code>`</code></p><p>//显示两个撇号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">``</span><br></pre></td></tr></table></figure><h3 id="12-图片"><a href="#12-图片" class="headerlink" title="12.图片"></a>12.图片</h3><p>图片的插入方式跟超链接前两种方式类似。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//方式1</span><br><span class="line">![如果图片不能显示，就显示这段文字](图片 url)</span><br><span class="line"></span><br><span class="line">//方式2</span><br><span class="line">![如果图片不能显示，就显示这段文字][Image-url]</span><br><span class="line">[Image-url]: 图片url &quot;这是提示文字&quot;</span><br></pre></td></tr></table></figure><p>效果如下:</p><p><img src="http://img3.imgtn.bdimg.com/it/u=3231339265,573244796&amp;fm=21&amp;gp=0.jpg" alt=""></p><p>![][Image-url]<br>[Image-url]: 图片url “这是提示文字”</p><h3 id="反斜杠"><a href="#反斜杠" class="headerlink" title="反斜杠 \"></a>反斜杠 \</h3><p>我们经常需要在文章中插入一些特殊符号，而这些符号恰好是前面所讲的标识符号，可以在特殊符号前插入\来直接显示符号，而不让Markdown来将其解释为标识符号。</p><p>Markdown支持以下这些符号前插入<code></code> 而显示其本来样子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">\ 反斜线</span><br><span class="line">` 反引号</span><br><span class="line">* 星号</span><br><span class="line">_ 底线</span><br><span class="line">&#123;&#125; 花括号</span><br><span class="line">[] 方括号</span><br><span class="line">() 括弧</span><br><span class="line"># 井字号</span><br><span class="line">+ 加号</span><br><span class="line">- 减号</span><br><span class="line">. 英文句号</span><br><span class="line">! 感叹号</span><br></pre></td></tr></table></figure><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><ul><li>Windows 环境下，推荐<a href="https://www.typora.io/" target="_blank" rel="noopener">Typora</a> 、<a href="http://markdownpad.com/" target="_blank" rel="noopener">Markdownpad</a></li><li>Mac环境下，推荐 <a href="http://25.io/mou/" target="_blank" rel="noopener">Mou</a></li><li>笔记软件：为知笔记较好的支持markdown，且支持Windows Mac Web IOS Android 各个平台</li><li>当然，还有Github</li></ul><h2 id="拓展阅读"><a href="#拓展阅读" class="headerlink" title="拓展阅读"></a>拓展阅读</h2><p><a href="http://wowubuntu.com/markdown/" target="_blank" rel="noopener">Markdown语法说明</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Markdown是一种轻量级的标记语言，用简单的标记语法就可以达到排版的目的，可以使我们更加专注于内容的编写，而不用过多的关注排版。本文主要整理了Markdown中常用的标记语法，便于以后查用。&lt;/p&gt;
&lt;h2 id=&quot;段落元素&quot;&gt;&lt;a href=&quot;#段落元素&quot; class
      
    
    </summary>
    
      <category term="MarkDown" scheme="http://blogliu.com.cn/categories/MarkDown/"/>
    
    
      <category term="编辑器" scheme="http://blogliu.com.cn/tags/%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    
      <category term="MarkDown" scheme="http://blogliu.com.cn/tags/MarkDown/"/>
    
  </entry>
  
  <entry>
    <title>再会</title>
    <link href="http://blogliu.com.cn/posts/209fe3d4/"/>
    <id>http://blogliu.com.cn/posts/209fe3d4/</id>
    <published>2016-12-10T06:36:21.000Z</published>
    <updated>2018-11-23T08:40:17.392Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://www.blogitliu.com" target="_blank" rel="noopener">http://www.blogitliu.com</a>  一年前申请的域名，不知不觉已然是2016年最后的一个月了，好一个时光如梭，岁月无情。再不记载点什么一年又这么浑浑噩噩的消逝了。当然，即便写下千言万语，还是改变不了没什么进步的一年的残酷现实。京城的冬日里难得几天连续晴朗，让人的心情也光明了一些，然而刚刚暗自欣喜了一下，就看到了明天雾霾红色预警的新闻。。。</p><p>  说说这个网站吧，其实折腾了也很久，早期弄Discuz社区，用的那个域名都不知道让自己扔哪个角落里去了，后来想写博客，就申请了新的域名，刚开始用WordPress  租的国外的空间，总是不稳定，再后来换了Hexo,Github的空间，省了很多事，技术折腾来折腾去，网站内容却没什么更新，总是做事情三分钟热度，所以很欣赏那些拥有好习惯的人，坚持去做一件事，真的是一种让人很是佩服的品质。就像博客标题里写的那样，再牛逼的梦想也抵不过傻逼一样的坚持。</p><p>  周末还是做了点事情，把 网站 <a href="http://www.blogitliu.com" target="_blank" rel="noopener">http://www.blogitliu.com</a>  的评论留言系统进行了更新，之前的留言系统是disqus,国外的一个非常不错的评论系统，但是万恶的天朝哎，在国内被墙了，目前换成了多说，还不知道稳定性怎么样，欢迎没事的同学前来测个试什么的，电脑访问哦，手机优化的不是很好。</p><p>  博客以后还是经常更新点东西吧，转载也好原创也好，万一哪天不作程序员了，是不是也可以去当个作家。。有时候脑子里总是会冒出各种千奇百怪的想法，就像书里写的那样“平行世界，多元生活，既可以朝九晚五，又能够浪迹天涯”，让人好生羡慕。</p><p>  无论发生了什么，日子还是一样的过，生活还是一样要面对，一切都是命中注定。祝顺利，平安。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://www.blogitliu.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.blogitliu.com&lt;/a&gt;  一年前申请的域名，不知不觉已然是2016年最后的一个月了，好一个时光如梭，岁月无情
      
    
    </summary>
    
      <category term="心情随笔" scheme="http://blogliu.com.cn/categories/%E5%BF%83%E6%83%85%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="生活" scheme="http://blogliu.com.cn/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="随笔" scheme="http://blogliu.com.cn/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>说点什么</title>
    <link href="http://blogliu.com.cn/posts/55640277/"/>
    <id>http://blogliu.com.cn/posts/55640277/</id>
    <published>2016-08-03T03:13:25.000Z</published>
    <updated>2018-11-23T08:40:17.393Z</updated>
    
    <content type="html"><![CDATA[<p>   这个荒芜之地已接近半年没有更新过了，幸运的是它还一直健在。我也不知道为什么自从更新几次之后就再也没能有心情和动力在这里做点什么，尽管这么长时间里我的生活已经改变了许多，但在这里却一点也没有体现。之前的一段时间曾一度想就此关闭，不过应该鲜有人知道在那段时间里原来的域名指向的并不是这儿。不过后来还是没有舍得，索性就恢复了。还好一切还是原来的样子，所有的功能也都正常。</p><p>这半年我来到了新的公司，认识了新的人，开始了新的生活，但这并不意味着就和老朋友们再无瓜葛，而是仍有不少交集。其实正是前两天某个朋友说要弄域名的时候，才让我决定了要重新开垦这片土地。</p><p>时间经历变化很多，很多熟悉的人都有了新的归宿，有人难得浪子回头，有人开始浪迹天涯，有人依然浪人浪语，可惜没人锒铛入狱。总之，大家都有了新的开始。但这些开始也仅仅只是开始，半年的时间放在许多事情的完整历程当中，还是显得那么短暂。但愿人长久吧。</p><p>不知道如果我不动声色的话，现在的这些文字多久后才会被人不经意间看到。但是当你看到时，还请刻意回首一下这一年过去的时光，看看自己是否有所改变，是否记忆犹鲜，不过无论怎样，都愿我们前程似锦，气象万千。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;   这个荒芜之地已接近半年没有更新过了，幸运的是它还一直健在。我也不知道为什么自从更新几次之后就再也没能有心情和动力在这里做点什么，尽管这么长时间里我的生活已经改变了许多，但在这里却一点也没有体现。之前的一段时间曾一度想就此关闭，不过应该鲜有人知道在那段时间里原来的域名指
      
    
    </summary>
    
      <category term="心情随笔" scheme="http://blogliu.com.cn/categories/%E5%BF%83%E6%83%85%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="生活" scheme="http://blogliu.com.cn/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="随笔" scheme="http://blogliu.com.cn/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>EventBus源码解读</title>
    <link href="http://blogliu.com.cn/posts/71d27a28/"/>
    <id>http://blogliu.com.cn/posts/71d27a28/</id>
    <published>2016-01-12T07:51:10.000Z</published>
    <updated>2018-11-23T08:40:17.404Z</updated>
    
    <content type="html"><![CDATA[<p>之前写了EventBus的使用详解，下面来详细分析一下EventBus的源码吧。  </p><p>转载相关博客：<br>EventBus源码研读:<a href="http://kymjs.com/code/2015/12/16/01" target="_blank" rel="noopener">http://kymjs.com/code/2015/12/16/01</a><br>EXECUTORSERVICE线程池讲解：<a href="http://www.cnphp6.com/archives/61093" target="_blank" rel="noopener">http://www.cnphp6.com/archives/61093</a><br>EventBus源码解析:<a href="http://www.trinea.cn/android/eventbus-source-analysis/" target="_blank" rel="noopener">http://www.trinea.cn/android/eventbus-source-analysis/</a><br>彻底理解ThreadLocal:<a href="http://blog.csdn.net/lufeng20/article/details/24314381" target="_blank" rel="noopener">http://blog.csdn.net/lufeng20/article/details/24314381</a></p><h1 id="进入源码世界"><a href="#进入源码世界" class="headerlink" title="进入源码世界"></a>进入源码世界</h1><h2 id="入口类EventBus类"><a href="#入口类EventBus类" class="headerlink" title="入口类EventBus类"></a>入口类EventBus类</h2><p>从使用的流程来看，首先是EventBus#getDefault()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EventBus <span class="title">getDefault</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(defaultInstance == <span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="keyword">synchronized</span>(EventBus.class)&#123;</span><br><span class="line"><span class="keyword">if</span>(defaultInstance == <span class="keyword">null</span>)&#123;</span><br><span class="line">defaultInstance = <span class="keyword">new</span> EventBus();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> defaultInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出是一个单例模式，调用构造方法，再看构造方法，调用一个重载的构造方法，重载的构造方法又需要一个EventBusBuilder对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">EventBus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>(DEFAULT_BUILDER);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EventBus(EventBusBuilder builder) &#123;</span><br><span class="line">       ......</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="EventBusBuilder类"><a href="#EventBusBuilder类" class="headerlink" title="EventBusBuilder类"></a>EventBusBuilder类</h2><p>这个类主要用来创建EventBus对象使用。包含的属性也是EventBus的一些参数设置，build函数用于新建EventBus对象,installDefaultEventBus函数将当前设置应用于Default EventBus。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EventBusBuilder</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ExecutorService DEFAULT_EXECUTOR_SERVICE = Executors.newCachedThreadPool();</span><br><span class="line">   <span class="keyword">boolean</span> logSubscriberExceptions = <span class="keyword">true</span>;</span><br><span class="line">   <span class="keyword">boolean</span> logNoSubscriberMessages = <span class="keyword">true</span>;</span><br><span class="line">   <span class="keyword">boolean</span> sendSubscriberExceptionEvent = <span class="keyword">true</span>;</span><br><span class="line">   <span class="keyword">boolean</span> sendNoSubscriberEvent = <span class="keyword">true</span>;</span><br><span class="line">   <span class="keyword">boolean</span> throwSubscriberException;</span><br><span class="line">   <span class="keyword">boolean</span> eventInheritance = <span class="keyword">true</span>;</span><br><span class="line">   ExecutorService executorService;</span><br><span class="line">   List&lt;Class&lt;?&gt;&gt; skipMethodVerificationForClasses;</span><br><span class="line"></span><br><span class="line">   EventBusBuilder() &#123;</span><br><span class="line">       <span class="keyword">this</span>.executorService = DEFAULT_EXECUTOR_SERVICE;</span><br><span class="line">   &#125;</span><br><span class="line">   ......</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>longSubscriberExceptions :当调用事件处理函数异常时是否打印异常信息，默认为true<br>longNoSubscriberMessages :没有订阅者订阅该事件时是否打印日志，默认为true<br>sendSubscriberExceptionEvent :当调用事件处理函数异常时是否发送SubscriberExceptionEvent事件，如果此开关打开，订阅者可以通过  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(SubscriberExceptionEvent event&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">......</span></span></span><br><span class="line"><span class="function"><span class="params">&#125;</span></span></span><br></pre></td></tr></table></figure></p><p>订阅该事件进行处理，默认为true.</p><p>sendNoSubscriberEvent :如果没有订阅者，发送一条默认事件<br>throwSubscriberException :当调用事件处理函数异常时是否抛出异常，默认为false,可通过<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EventBus.builder().</span><br><span class="line">throwSubscriberException(<span class="keyword">true</span>).installDefaultEventBus()</span><br></pre></td></tr></table></figure></p><p>打开。<br>eventInheritance :event的子类是否也能响应订阅者<br>executorService :异步，BackGround处理方式的线程池  </p><p>通过上面可以看出，EventBus.getDefault()方法会创建一个默认的EventBusBuilder，如果我们想修改EventBusBuilder的一些配置选项，可以通过EventBus.builder()方法生成一个EventBusBuidler,然后设置自定义配置选项，最后调用installDefaultEventBus方法创建一个EventBus对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> EventBus <span class="title">installDefaultEventBus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       Class var1 = EventBus.class;</span><br><span class="line">       <span class="keyword">synchronized</span>(EventBus.class) &#123;</span><br><span class="line">           <span class="keyword">if</span>(EventBus.defaultInstance != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Default instance already exists. It may be only set once before it\'s used the first time to ensure consistent behavior."</span>);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               EventBus.defaultInstance = <span class="keyword">this</span>.build();</span><br><span class="line">               <span class="keyword">return</span> EventBus.defaultInstance;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="三个Poster类"><a href="#三个Poster类" class="headerlink" title="三个Poster类"></a>三个Poster类</h2><p>分析完EventBusBuilder，再来看EventBus的构造方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">EventBus(EventBusBuilder builder) &#123;</span><br><span class="line">       <span class="keyword">this</span>.currentPostingThreadState = <span class="keyword">new</span> ThreadLocal() &#123;</span><br><span class="line">           <span class="keyword">protected</span> EventBus.<span class="function">PostingThreadState <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">new</span> EventBus.PostingThreadState();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;;</span><br><span class="line">       <span class="keyword">this</span>.subscriptionsByEventType = <span class="keyword">new</span> HashMap();</span><br><span class="line">       <span class="keyword">this</span>.typesBySubscriber = <span class="keyword">new</span> HashMap();</span><br><span class="line">       <span class="keyword">this</span>.stickyEvents = <span class="keyword">new</span> ConcurrentHashMap();</span><br><span class="line">       <span class="keyword">this</span>.mainThreadPoster = <span class="keyword">new</span> HandlerPoster(<span class="keyword">this</span>, Looper.getMainLooper(), <span class="number">10</span>);</span><br><span class="line">       <span class="keyword">this</span>.backgroundPoster = <span class="keyword">new</span> BackgroundPoster(<span class="keyword">this</span>);</span><br><span class="line">       <span class="keyword">this</span>.asyncPoster = <span class="keyword">new</span> AsyncPoster(<span class="keyword">this</span>);</span><br><span class="line">       <span class="keyword">this</span>.subscriberMethodFinder = <span class="keyword">new</span> SubscriberMethodFinder(builder.skipMethodVerificationForClasses);</span><br><span class="line">       <span class="keyword">this</span>.logSubscriberExceptions = builder.logSubscriberExceptions;</span><br><span class="line">       <span class="keyword">this</span>.logNoSubscriberMessages = builder.logNoSubscriberMessages;</span><br><span class="line">       <span class="keyword">this</span>.sendSubscriberExceptionEvent = builder.sendSubscriberExceptionEvent;</span><br><span class="line">       <span class="keyword">this</span>.sendNoSubscriberEvent = builder.sendNoSubscriberEvent;</span><br><span class="line">       <span class="keyword">this</span>.throwSubscriberException = builder.throwSubscriberException;</span><br><span class="line">       <span class="keyword">this</span>.eventInheritance = builder.eventInheritance;</span><br><span class="line">       <span class="keyword">this</span>.executorService = builder.executorService;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>HandlerPoster、BackgroundPoster、AsyncPoster<br>HandlerPoster:前台发送者<br>BackgroundPoster:后台发送者<br>AsyncPoster:后台发送者，只让队列的最后一个待订阅者去响应</p><p>每个Poster中都有一个任务队列，PendingPostQueue<br>PendingPostQueue中定义了两个节点，队列的头节点和尾节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> PendingPost head;</span><br><span class="line">   <span class="keyword">private</span> PendingPost tail;</span><br></pre></td></tr></table></figure><p>PengdingPost类的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PendingPost</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;PendingPost&gt; pendingPostPool = <span class="keyword">new</span> ArrayList();</span><br><span class="line">   Object event;</span><br><span class="line">   Subscription subscription;</span><br><span class="line">   PendingPost next;</span><br><span class="line">   ......</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>首先提供了一个池的设计，类似于我们的线程池，目的是为了减少对象创建的开销，当一个对象不用了，我们可以留着它，下次再需要的时候返回这个保留的而不是再去创建。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> PendingPost <span class="title">obtainPendingPost</span><span class="params">(Subscription subscription, Object event)</span> </span>&#123;</span><br><span class="line">        List var2 = pendingPostPool;</span><br><span class="line">        <span class="keyword">synchronized</span>(pendingPostPool) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = pendingPostPool.size();</span><br><span class="line">            <span class="keyword">if</span>(size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                PendingPost pendingPost = (PendingPost)pendingPostPool.remove(size - <span class="number">1</span>);</span><br><span class="line">                pendingPost.event = event;</span><br><span class="line">                pendingPost.subscription = subscription;</span><br><span class="line">                pendingPost.next = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">return</span> pendingPost;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PendingPost(event, subscription);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的方法会检查线程池中是否有可复用的，如果有可用的，返回可复用对象，如果没有可复用的，创建一个新的PendingPost对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">releasePendingPost</span><span class="params">(PendingPost pendingPost)</span> </span>&#123;</span><br><span class="line">        pendingPost.event = <span class="keyword">null</span>;</span><br><span class="line">        pendingPost.subscription = <span class="keyword">null</span>;</span><br><span class="line">        pendingPost.next = <span class="keyword">null</span>;</span><br><span class="line">        List var1 = pendingPostPool;</span><br><span class="line">        <span class="keyword">synchronized</span>(pendingPostPool) &#123;</span><br><span class="line">            <span class="keyword">if</span>(pendingPostPool.size() &lt; <span class="number">10000</span>) &#123;</span><br><span class="line">                pendingPostPool.add(pendingPost);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述方法回收PengingPost对象，为了防止池无线增长，增加了size&lt;1000的判断。</p><p>PendingPost分析完之后，我们看PendingPostQueue的出列和入列方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(PendingPost pendingPost)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(pendingPost == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"null cannot be enqueued"</span>);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">if</span>(<span class="keyword">this</span>.tail != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">this</span>.tail.next = pendingPost;</span><br><span class="line">               <span class="keyword">this</span>.tail = pendingPost;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">if</span>(<span class="keyword">this</span>.head != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Head present, but no tail"</span>);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">this</span>.head = <span class="keyword">this</span>.tail = pendingPost;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">this</span>.notifyAll();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>首先是入列方式，tail尾的next指向当前正在入队的节点，tail指向自己（自己变成了最后一个节点），完成入队。如果是第一个元素，将head和tail都指向自己就可以了。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> PendingPost <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        PendingPost pendingPost = <span class="keyword">this</span>.head;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.head = <span class="keyword">this</span>.head.next;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.head == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.tail = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pendingPost;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>pendingPost为要出队的节点，将head指向head的next，完成出队，如果只有一个元素，tail置空。</p><p>PendingPostQueue再往上一级，是HandlerPost的enqueue方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Subscription subscription, Object event)</span> </span>&#123;</span><br><span class="line">        PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event);</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.queue.enqueue(pendingPost);</span><br><span class="line">            <span class="keyword">if</span>(!<span class="keyword">this</span>.handlerActive) &#123;</span><br><span class="line">                <span class="keyword">this</span>.handlerActive = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(!<span class="keyword">this</span>.sendMessage(<span class="keyword">this</span>.obtainMessage())) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Could not send handler message"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>根据输入参数，生成待发送对象PendingPost,然后加入队列，如果此时handlerActive是false的话，发送一条空的消息激活handler,然后是handleMessage()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">boolean</span> rescheduled = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">long</span> started = SystemClock.uptimeMillis();</span><br><span class="line"></span><br><span class="line">           <span class="keyword">long</span> timeInMethod;</span><br><span class="line">           <span class="keyword">do</span> &#123;</span><br><span class="line">               PendingPost pendingPost = <span class="keyword">this</span>.queue.poll();</span><br><span class="line">               <span class="keyword">if</span>(pendingPost == <span class="keyword">null</span>) &#123;</span><br><span class="line">                   <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">                       pendingPost = <span class="keyword">this</span>.queue.poll();</span><br><span class="line">                       <span class="keyword">if</span>(pendingPost == <span class="keyword">null</span>) &#123;</span><br><span class="line">                           <span class="keyword">this</span>.handlerActive = <span class="keyword">false</span>;</span><br><span class="line">                           <span class="keyword">return</span>;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">this</span>.eventBus.invokeSubscriber(pendingPost);</span><br><span class="line">               timeInMethod = SystemClock.uptimeMillis() - started;</span><br><span class="line">           &#125; <span class="keyword">while</span>(timeInMethod &lt; (<span class="keyword">long</span>)<span class="keyword">this</span>.maxMillisInsideHandleMessage);</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span>(!<span class="keyword">this</span>.sendMessage(<span class="keyword">this</span>.obtainMessage())) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Could not send handler message"</span>);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           rescheduled = <span class="keyword">true</span>;</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="keyword">this</span>.handlerActive = rescheduled;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>handleMessage不停的去待发送队列queue中去取消息（timeInMehtod&lt;maxMillisInsideHandleMessage,加判断为了防止主线程ANR），最终通过eventBus的invokeSubscriber方法发送出去，让注册了的订阅者去响应。<br>关于BackgroundPoster、AsyncPoster原理与HandlerPoster类似，这两个是工作在异步，实现Runnable接口，用到了ExecutorService。</p><h2 id="Subscribe流程"><a href="#Subscribe流程" class="headerlink" title="Subscribe流程"></a>Subscribe流程</h2><p>分析完EventBus的构造函数，下面看一下入口方法register().</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Object subscriber, <span class="keyword">boolean</span> sticky, <span class="keyword">int</span> priority)</span> </span>&#123;</span><br><span class="line">        List subscriberMethods = <span class="keyword">this</span>.subscriberMethodFinder.findSubscriberMethods(subscriber.getClass());</span><br><span class="line">        Iterator var5 = subscriberMethods.iterator();</span><br><span class="line">        <span class="keyword">while</span>(var5.hasNext()) &#123;</span><br><span class="line">            SubscriberMethod subscriberMethod = (SubscriberMethod)var5.next();</span><br><span class="line">            <span class="keyword">this</span>.subscribe(subscriber, subscriberMethod, sticky, priority);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SubscriberMethod类"><a href="#SubscriberMethod类" class="headerlink" title="SubscriberMethod类"></a>SubscriberMethod类</h3><p>从字面意思是订阅者方法，看看类中的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Method method;</span><br><span class="line">   <span class="keyword">final</span> ThreadMode threadMode;</span><br><span class="line">   <span class="keyword">final</span> Class&lt;?&gt; eventType;</span><br><span class="line">   String methodString;</span><br><span class="line">   SubscriberMethod(Method method, ThreadMode threadMode, Class&lt;?&gt; eventType) &#123;</span><br><span class="line">       <span class="keyword">this</span>.method = method;</span><br><span class="line">       <span class="keyword">this</span>.threadMode = threadMode;</span><br><span class="line">       <span class="keyword">this</span>.eventType = eventType;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">checkMethodString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(<span class="keyword">this</span>.methodString == <span class="keyword">null</span>) &#123;</span><br><span class="line">           StringBuilder builder = <span class="keyword">new</span> StringBuilder(<span class="number">64</span>);</span><br><span class="line">           builder.append(<span class="keyword">this</span>.method.getDeclaringClass().getName());</span><br><span class="line">           builder.append(<span class="string">'#'</span>).append(<span class="keyword">this</span>.method.getName());</span><br><span class="line">           builder.append(<span class="string">'('</span>).append(<span class="keyword">this</span>.eventType.getName());</span><br><span class="line">           <span class="keyword">this</span>.methodString = builder.toString();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>Method：方法名<br>ThreadMode:一个枚举类<br>checkMehtodString()方法是为了设置变量methodString的值  </p><h3 id="SubscriberMethodFinder类"><a href="#SubscriberMethodFinder类" class="headerlink" title="SubscriberMethodFinder类"></a>SubscriberMethodFinder类</h3><p>subscriberMethodFinder类主要是通过反射的方法来判断传入的this对象中是否有onEvent开头的方法的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">filterSubscriberMethods</span><span class="params">(List&lt;SubscriberMethod&gt; subscriberMethods,</span></span></span><br><span class="line"><span class="function"><span class="params">                                         HashMap&lt;String, Class&gt; eventTypesFound, StringBuilder methodKeyBuilder,</span></span></span><br><span class="line"><span class="function"><span class="params">                                         Method[] methods)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">            String methodName = method.getName();</span><br><span class="line">            <span class="keyword">if</span> (methodName.startsWith(ON_EVENT_METHOD_NAME)) &#123;</span><br><span class="line">                <span class="keyword">int</span> modifiers = method.getModifiers();</span><br><span class="line">                Class&lt;?&gt; methodClass = method.getDeclaringClass();</span><br><span class="line">                <span class="keyword">if</span> ((modifiers &amp; Modifier.PUBLIC) != <span class="number">0</span> &amp;&amp; (modifiers &amp; MODIFIERS_IGNORE) == <span class="number">0</span>) &#123;</span><br><span class="line">                ......</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>通过对全部的方法遍历，为了效率首先做一次筛选，只关注我们的以 “onEvent” 开头的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ThreadMode <span class="title">getThreadMode</span><span class="params">(Class&lt;?&gt; clazz, Method method, String methodName)</span> </span>&#123;</span><br><span class="line">        String modifierString = methodName.substring(ON_EVENT_METHOD_NAME.length());</span><br><span class="line">        ThreadMode threadMode;</span><br><span class="line">        <span class="keyword">if</span> (modifierString.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            threadMode = ThreadMode.PostThread;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (modifierString.equals(<span class="string">"MainThread"</span>)) &#123;</span><br><span class="line">            threadMode = ThreadMode.MainThread;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (modifierString.equals(<span class="string">"BackgroundThread"</span>)) &#123;</span><br><span class="line">            threadMode = ThreadMode.BackgroundThread;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (modifierString.equals(<span class="string">"Async"</span>)) &#123;</span><br><span class="line">            threadMode = ThreadMode.Async;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!skipMethodVerificationForClasses.containsKey(clazz)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Illegal onEvent method, check for typos: "</span> + method);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                threadMode = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> threadMode;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里我们看到，其实EventBus不仅仅支持onEvent()的回调，它还支持onEventMainThread()、onEventBackgroundThread()、onEventAsync()这三个方法的回调。<br>一直到最后，我们看到这个方法把所有的方法名集合作为value，类名作为key存入了 methodCache 这个全局静态变量中。意味着，整个库在运行期间所有遍历的方法都会存在这个 map 中，而不必每次都去做耗时的反射取方法了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(methodCache) &#123;</span><br><span class="line">   methodCache.put(subscriberClass, subscriberMethods1);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(methodCache) &#123;</span><br><span class="line">     subscriberMethods = (List)methodCache.get(subscriberClass);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h2 id="事件的处理与发送subscribe"><a href="#事件的处理与发送subscribe" class="headerlink" title="事件的处理与发送subscribe()"></a>事件的处理与发送subscribe()</h2><p>subscribe()方法方法接收四个参数：订阅者封装的对象、响应方法名封装的对象、是否为粘滞事件、这条事件的优先级。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// Must be called in synchronized block</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(Object subscriber, SubscriberMethod subscriberMethod, <span class="keyword">boolean</span> sticky, <span class="keyword">int</span> priority)</span> </span>&#123;</span><br><span class="line">        Class&lt;?&gt; eventType = subscriberMethod.eventType;</span><br><span class="line">        CopyOnWriteArrayList&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType);</span><br><span class="line">        Subscription newSubscription = <span class="keyword">new</span> Subscription(subscriber, subscriberMethod, priority);</span><br><span class="line">        <span class="keyword">if</span> (subscriptions == <span class="keyword">null</span>) &#123;</span><br><span class="line">            subscriptions = <span class="keyword">new</span> CopyOnWriteArrayList&lt;Subscription&gt;();</span><br><span class="line">            subscriptionsByEventType.put(eventType, subscriptions);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (subscriptions.contains(newSubscription)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Subscriber "</span> + subscriber.getClass() + <span class="string">" already registered to event "</span></span><br><span class="line">                        + eventType);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Starting with EventBus 2.2 we enforced methods to be public (might change with annotations again)</span></span><br><span class="line">        <span class="comment">// subscriberMethod.method.setAccessible(true);</span></span><br><span class="line">        <span class="keyword">int</span> size = subscriptions.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= size; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == size || newSubscription.priority &gt; subscriptions.get(i).priority) &#123;</span><br><span class="line">                subscriptions.add(i, newSubscription);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Class&lt;?&gt;&gt; subscribedEvents = typesBySubscriber.get(subscriber);</span><br><span class="line">        <span class="keyword">if</span> (subscribedEvents == <span class="keyword">null</span>) &#123;</span><br><span class="line">            subscribedEvents = <span class="keyword">new</span> ArrayList&lt;Class&lt;?&gt;&gt;();</span><br><span class="line">            typesBySubscriber.put(subscriber, subscribedEvents);</span><br><span class="line">        &#125;</span><br><span class="line">        subscribedEvents.add(eventType);</span><br><span class="line">        .......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个订阅者是可以有多个重载的onEvent()方法的，所以这里多做了一步，将所有订阅者的响应方法保存到subscribedEvents中。</p><p>注：子事件也可以让响应父事件的 onEvent() 。这个有点绕，举个例子，订阅者的onEvent(CharSequence),如果传一个String类型的值进去，默认情况下是不会响应的，但如果我们在构建的时候设置了 eventInheritance 为 true ,那么它就会响应了。</p><h2 id="post-方法调用流程"><a href="#post-方法调用流程" class="headerlink" title="post()方法调用流程"></a>post()方法调用流程</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">post</span><span class="params">(Object event)</span> </span>&#123;</span><br><span class="line">        PostingThreadState postingState = currentPostingThreadState.get();</span><br><span class="line">        List&lt;Object&gt; eventQueue = postingState.eventQueue;</span><br><span class="line">        eventQueue.add(event);</span><br><span class="line">        <span class="keyword">if</span> (!postingState.isPosting) &#123;</span><br><span class="line">            postingState.isMainThread = Looper.getMainLooper() == Looper.myLooper();</span><br><span class="line">            postingState.isPosting = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (postingState.canceled) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Internal error. Abort state was not reset"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (!eventQueue.isEmpty()) &#123;</span><br><span class="line">                    postSingleEvent(eventQueue.remove(<span class="number">0</span>), postingState);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                postingState.isPosting = <span class="keyword">false</span>;</span><br><span class="line">                postingState.isMainThread = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>post() 方法首先从 currentPostingThreadState 对象中取了一个 PostingThreadState ，我们来看看这个 currentPostingThreadState 对象的创建代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ThreadLocal&lt;PostingThreadState&gt; currentPostingThreadState = <span class="keyword">new</span></span><br><span class="line">ThreadLocal&lt;PostingThreadState&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> PostingThreadState <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PostingThreadState();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>ThreadLocal 是一个线程内部的数据存储类，通过它可以在指定的线程中存储数据，而这段数据是不会与其他线程共享的。其内部原理是通过生成一个它包裹的泛型对象的数组，在不同的线程会有不同的数组索引值，通过这样就可以做到每个线程通过 get() 方法获取的时候，取到的只能是自己线程所对应的数据。<br>在 EventBus 中， ThreadLocal 所包裹的是一个 PostingThreadState 类，它仅仅是封装了一些事件发送中过程所需的数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PostingThreadState</span> </span>&#123;</span><br><span class="line">    <span class="comment">//通过post方法参数传入的事件集合</span></span><br><span class="line">    <span class="keyword">final</span> List&lt;Object&gt; eventQueue = <span class="keyword">new</span> ArrayList&lt;Object&gt;(); </span><br><span class="line">    <span class="keyword">boolean</span> isPosting; <span class="comment">//是否正在执行postSingleEvent()方法</span></span><br><span class="line">    <span class="keyword">boolean</span> isMainThread;</span><br><span class="line">    Subscription subscription;</span><br><span class="line">    Object event;</span><br><span class="line">    <span class="keyword">boolean</span> canceled;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>回到 post() 方法，我们看到其核心代码是这句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!eventQueue.isEmpty()) &#123;</span><br><span class="line">    postSingleEvent(eventQueue.remove(<span class="number">0</span>), postingState);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>次调用post()的时候都会传入一个事件，这个事件会被加入到队列。而每次执行postSingleEvent()都会从队列中取出一个事件，这样不停循环取出事件处理，直到队列全部取完。<br>再看 postSingleEvent() 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postSingleEvent</span><span class="params">(Object event, PostingThreadState postingState)</span> <span class="keyword">throws</span> Error </span>&#123;</span><br><span class="line">    Class&lt;?&gt; eventClass = event.getClass();</span><br><span class="line">    <span class="keyword">boolean</span> subscriptionFound = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (eventInheritance) &#123;</span><br><span class="line">        <span class="comment">//获取到eventClass所有父类的集合</span></span><br><span class="line">        List&lt;Class&lt;?&gt;&gt; eventTypes = lookupAllEventTypes(eventClass);</span><br><span class="line">        <span class="keyword">int</span> countTypes = eventTypes.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> h = <span class="number">0</span>; h &lt; countTypes; h++) &#123;</span><br><span class="line">            Class&lt;?&gt; clazz = eventTypes.get(h);</span><br><span class="line">            <span class="comment">//左或右只要有一个为真则为真,并赋值给左</span></span><br><span class="line">            subscriptionFound |= postSingleEventForEventType(event, postingState, clazz);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        subscriptionFound = postSingleEventForEventType(event, postingState, eventClass);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!subscriptionFound) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logNoSubscriberMessages) &#123;</span><br><span class="line">            Log.d(TAG, <span class="string">"No subscribers registered for event "</span> + eventClass);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//参考sendNoSubscriberEvent注释</span></span><br><span class="line">        <span class="keyword">if</span> (sendNoSubscriberEvent &amp;&amp; eventClass != NoSubscriberEvent.class &amp;&amp;</span><br><span class="line">                eventClass != SubscriberExceptionEvent.class) &#123;</span><br><span class="line">            post(<span class="keyword">new</span> NoSubscriberEvent(<span class="keyword">this</span>, event));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还记得 EventBusBuild 中的 eventInheritance是做什么的吗？它表示一个子类事件能否响应父类的 onEvent() 方法。<br>再往下看 lookupAllEventTypes() 它通过循环和递归一起用，将一个类的父类,接口,父类的接口,父类接口的父类,全部添加到全局静态变量 eventTypes 集合中。之所以用全局静态变量的好处在于用全局静态变量只需要将那耗时又复杂的循环+递归方法执行一次就够了，下次只需要通过 key:事件类名 来判断这个事件是否以及执行过 lookupAllEventTypes() 方法。</p><h3 id="postSingleEventForEventType-方法"><a href="#postSingleEventForEventType-方法" class="headerlink" title="postSingleEventForEventType()方法"></a>postSingleEventForEventType()方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">postSingleEventForEventType</span><span class="params">(Object event, PostingThreadState postingState, Class&lt;?&gt; eventClass)</span> </span>&#123;</span><br><span class="line">    CopyOnWriteArrayList&lt;Subscription&gt; subscriptions;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">//所有订阅了eventClass的事件集合</span></span><br><span class="line">        subscriptions = subscriptionsByEventType.get(eventClass);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (subscriptions != <span class="keyword">null</span> &amp;&amp; !subscriptions.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">//回调subscription的响应方法</span></span><br><span class="line">        <span class="keyword">for</span> (Subscription subscription : subscriptions) &#123;</span><br><span class="line">            postingState.event = event;</span><br><span class="line">            postingState.subscription = subscription;</span><br><span class="line">            <span class="keyword">boolean</span> aborted = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                postToSubscription(subscription, event, postingState.isMainThread);</span><br><span class="line">                aborted = postingState.canceled;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                postingState.event = <span class="keyword">null</span>;</span><br><span class="line">                postingState.subscription = <span class="keyword">null</span>;</span><br><span class="line">                postingState.canceled = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (aborted) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取到所有订阅了 eventClass 的事件集合，之前有讲过， subscriptionsByEventType 是一个以 key:订阅的事件 value:订阅这个事件的所有订阅者集合 的 Map 。<br>最后通过循环，遍历所有订阅了 eventClass 事件的订阅者，并向每一个订阅者发送事件。<br>看它的发送事件的方法：<br>postToSubscription(subscription, event, postingState.isMainThread);<br>噢，又回到了和之前 Subscribe 流程中处理粘滞事件相同的方法里————对声明不同线程模式的事件做不同的响应方法，最终都是通过invokeSubscriber()反射订阅者类中的以onEvent开头的方法。</p><h2 id="unregister"><a href="#unregister" class="headerlink" title="unregister()"></a>unregister()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">unregister</span><span class="params">(Object subscriber)</span> </span>&#123;</span><br><span class="line">    List&lt;Class&lt;?&gt;&gt; subscribedTypes = typesBySubscriber.get(subscriber);</span><br><span class="line">    <span class="keyword">if</span> (subscribedTypes != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Class&lt;?&gt; eventType : subscribedTypes) &#123;</span><br><span class="line">            <span class="comment">//取消注册subscriber对eventType事件的响应</span></span><br><span class="line">            unsubscribeByEventType(subscriber, eventType);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当subscriber对所有事件都不响应以后,移除订阅者</span></span><br><span class="line">        typesBySubscriber.remove(subscriber);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之前讲过typesBySubscriber key:订阅者对象 value:这个订阅者订阅的事件集合，表示当前订阅者订阅了哪些事件。<br>首先遍历要取消注册的订阅者订阅的每一个事件，调用unsubscribeByEventType(),从这个事件的所有订阅者集合中将要取消注册的订阅者移除。最后再以：当前订阅者为 key 全部订阅事件集合为 value 的一个 Map 的 Entry 移除，就完成了取消注册的全部过程。</p><h2 id="EventBus工作原理"><a href="#EventBus工作原理" class="headerlink" title="EventBus工作原理"></a>EventBus工作原理</h2><p>最后我们再来从设计者的角度看一看EventBus的工作原理。</p><h3 id="订阅的逻辑"><a href="#订阅的逻辑" class="headerlink" title="订阅的逻辑"></a>订阅的逻辑</h3><p>1、首先是调用register()方法注册一个订阅者A。<br>2、遍历这个订阅者A的全部以onEvent开头的订阅方法。<br>3、将A订阅的所有事件分别作为 key，所有能响应 key 事件的订阅者的集合作为 value，存入 Map&lt;事件，List&lt;订阅这个事件的订阅者&gt;&gt;。   4、以A的类名为 key，所有 onEvent 参数类型的类名组成的集合为 value，存入 Map&lt;订阅者，List&lt;订阅的事件&gt;&gt;。<br> 4.1、如果是订阅了粘滞事件的订阅者，从粘滞事件缓存区获取之前发送过的粘滞事件，响应这些粘滞事件。</p><h3 id="发送事件的逻辑"><a href="#发送事件的逻辑" class="headerlink" title="发送事件的逻辑"></a>发送事件的逻辑</h3><p>1、取当前线程的发送事件封装数据，并从封装的数据中拿到发送事件的事件队列。<br>2、将要发送的事件加入到事件队列中去。<br>3、循环，每次发送队列中的一条事件给所有订阅了这个事件的订阅者。<br>3.1、如果是子事件可以响应父事件的事件模式，需要先将这个事件的所有父类、接口、父类的接口、父类接口的父类都找到，并让订阅了这些父类信息的订阅者也都响应这条事件。</p><h3 id="响应事件的逻辑"><a href="#响应事件的逻辑" class="headerlink" title="响应事件的逻辑"></a>响应事件的逻辑</h3><p>1、发送事件处理完成后会将事件交给负责响应的逻辑部分。<br>2、首先判断时间的响应模式，响应模式分为四种：<br>PostThread 在哪个线程调用的post()方法，就在哪个线程执行响应方法。<br>MainThread 无论是在哪个线程调用的post()方法，最终都在主线程执行响应方法。<br>BackgroundThread 无论是在哪个线程调用的post()方法，最终都在后台线程执行响应方法。(串行执行，一次只执行一个任务，其他任务在队列中处于等待状态)<br>Async 无论是在哪个线程调用的post()方法，最终都在后台线程执行响应方法。(并行执行，只要有任务就开一个线程让他执行)</p><h3 id="取消注册的逻辑"><a href="#取消注册的逻辑" class="headerlink" title="取消注册的逻辑"></a>取消注册的逻辑</h3><p>1、首先是调用unregister()方法拿到要取消注册的订阅者B。<br>2、从这个类订阅的时候存入的 Map&lt;订阅者，List&lt;订阅的事件&gt;&gt; 中，拿到这个类的订阅事件集合。<br>3、遍历订阅时间集合，在注册的时候存入的 Map&lt;事件，List&lt;订阅这个事件的订阅者&gt;&gt; 中将对应订阅事件的订阅者集合中的这个订阅者移除。<br>   4、将步骤2中的 Map&lt;订阅者，List&lt;订阅的事件&gt;&gt; 中这个订阅者相关的 Entry 移除。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前写了EventBus的使用详解，下面来详细分析一下EventBus的源码吧。  &lt;/p&gt;
&lt;p&gt;转载相关博客：&lt;br&gt;EventBus源码研读:&lt;a href=&quot;http://kymjs.com/code/2015/12/16/01&quot; target=&quot;_blank&quot; r
      
    
    </summary>
    
      <category term="移动开发" scheme="http://blogliu.com.cn/categories/%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="EventBus" scheme="http://blogliu.com.cn/tags/EventBus/"/>
    
      <category term="Android" scheme="http://blogliu.com.cn/tags/Android/"/>
    
      <category term="GitHub" scheme="http://blogliu.com.cn/tags/GitHub/"/>
    
  </entry>
  
  <entry>
    <title>2016,变成更好的自己</title>
    <link href="http://blogliu.com.cn/posts/299953da/"/>
    <id>http://blogliu.com.cn/posts/299953da/</id>
    <published>2016-01-10T07:57:56.000Z</published>
    <updated>2018-11-23T08:40:17.384Z</updated>
    
    <content type="html"><![CDATA[<p>欣赏拥有好习惯的人，比如说每天按时跑步，每晚坚持读书，每顿早餐都喝一杯牛奶。这种习惯可大可小，但它标明了一种清洁性的自律，也表达着对生活的一种偏执，它有某种程度的强迫性，但也因为此，它使人的生命质地有了不同。如果还没有找到为之奋斗的目标，那么先从坚持一个好习惯开始吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;欣赏拥有好习惯的人，比如说每天按时跑步，每晚坚持读书，每顿早餐都喝一杯牛奶。这种习惯可大可小，但它标明了一种清洁性的自律，也表达着对生活的一种偏执，它有某种程度的强迫性，但也因为此，它使人的生命质地有了不同。如果还没有找到为之奋斗的目标，那么先从坚持一个好习惯开始吧。&lt;/p
      
    
    </summary>
    
      <category term="心情随笔" scheme="http://blogliu.com.cn/categories/%E5%BF%83%E6%83%85%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="生活" scheme="http://blogliu.com.cn/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="随笔" scheme="http://blogliu.com.cn/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>EventBus使用详解</title>
    <link href="http://blogliu.com.cn/posts/8d3d210c/"/>
    <id>http://blogliu.com.cn/posts/8d3d210c/</id>
    <published>2016-01-09T15:52:53.000Z</published>
    <updated>2018-11-23T08:40:17.402Z</updated>
    
    <content type="html"><![CDATA[<p>前言：EventBus出来有一段时间了，github上面也有很多开源项目中用到<br>了EventBus。所以抽空学习顺便整理了一下。</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>EventBus是针一款对Android的发布/订阅事件总线。它可以让我们很轻松的实现在Android各个组件之间传递消息，并且代码的可读性更好，耦合度更低。</p><h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p>(1)首先需要定义一个消息类，该类可以不继承任何基类也不需要实现任何接口。如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageEvent</span> </span>&#123;</span><br><span class="line">   ......</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>(2)在需要订阅事件的地方注册事件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EventBus.getDefault().register(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><p>(3)产生事件，即发送消息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EventBus.getDefault().post(messageEvent);</span><br></pre></td></tr></table></figure><p>(4)处理消息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(MessageEvent messageEvent)</span> </span>&#123;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(5)取消消息订阅</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EventBus.getDefault().unregister(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><h2 id="有何优点"><a href="#有何优点" class="headerlink" title="有何优点"></a>有何优点</h2><p>采用消息发布/订阅的一个很大的优点就是代码的简洁性，并且能够有效地降低消息发布者和订阅者之间的耦合度。<br>举个例子，比如有两个界面，ActivityA和ActivityB，从ActivityA界面跳转到ActivityB界面后，ActivityB要给ActivityA发送一个消息，ActivityA收到消息后在界面上显示出来。我们最先想到的方法就是使用广播，使用广播实现此需求的代码如下：<br>首先需要在ActivityA中定义一个广播接收器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageBroadcastReceiver</span> <span class="keyword">extends</span> <span class="title">BroadcastReceiver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>&#123;</span><br><span class="line">       mMessageView.setText(<span class="string">"Message from SecondActivity:"</span> + intent.getStringExtra(<span class="string">"message"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还需要在onCreate()方法中注册广播接收器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_main);</span><br><span class="line">    <span class="comment">//注册事件</span></span><br><span class="line">    EventBus.getDefault().register(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//注册广播</span></span><br><span class="line">    IntentFilter intentFilter = <span class="keyword">new</span> IntentFilter(<span class="string">"message_broadcast"</span>);</span><br><span class="line">    mBroadcastReceiver = <span class="keyword">new</span> MessageBroadcastReceiver();</span><br><span class="line">    registerReceiver(mBroadcastReceiver, intentFilter);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在onDestory()方法中取消注册广播接收器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">super</span>.onDestroy();</span><br><span class="line">   ......</span><br><span class="line">   <span class="comment">//取消广播注册</span></span><br><span class="line">   unregisterReceiver(mBroadcastReceiver);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后我们需要在ActivityB界面中发送广播消息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">findViewById(R.id.send_broadcast).setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        String message = mMessageET.getText().toString();</span><br><span class="line">        <span class="keyword">if</span>(TextUtils.isEmpty(message)) &#123;</span><br><span class="line">            message = <span class="string">"defaule message"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">        intent.setAction(<span class="string">"message_broadcast"</span>);</span><br><span class="line">        intent.putExtra(<span class="string">"message"</span>, message);</span><br><span class="line">        sendBroadcast(intent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>看着上面的实现代码，感觉也没什么不妥，挺好的！下面对比看下使用EventBus如何实现。<br>根据文章最前面所讲的EventBus使用步骤，首先我们需要定义一个消息事件类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageEvent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MessageEvent</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.message = message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMessage</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.message = message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在ActivityA界面中我们首先需要注册订阅事件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_main);</span><br><span class="line">    <span class="comment">//注册事件</span></span><br><span class="line">    EventBus.getDefault().register(<span class="keyword">this</span>);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在onDestory()方法中取消订阅：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onDestroy();</span><br><span class="line">    <span class="comment">//取消事件注册</span></span><br><span class="line">    EventBus.getDefault().unregister(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然还要定义一个消息处理的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(MessageEvent messageEvent)</span> </span>&#123;</span><br><span class="line">   mMessageView.setText(<span class="string">"Message from SecondActivity:"</span> + messageEvent.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，消息订阅者我们已经定义好了，我们还需要在ActivityB中发布消息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">findViewById(R.id.send).setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        String message = mMessageET.getText().toString();</span><br><span class="line">        <span class="keyword">if</span>(TextUtils.isEmpty(message)) &#123;</span><br><span class="line">            message = <span class="string">"defaule message"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        EventBus.getDefault().post(<span class="keyword">new</span> MessageEvent(message));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>对比代码一看，有人会说了，这尼玛有什么区别嘛！说好的简洁呢？哥们，别着急嘛！我这里只是举了个简单的例子，仅仅从该例子来看，EventBus的优势没有体现出来。现在我将需求稍微改一下，ActivityA收到消息后，需要从网络服务器获取数据并将数据展示出来。如果使用广播，ActivityA中广播接收器代码应该这么写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageBroadcastReceiver</span> <span class="keyword">extends</span> <span class="title">BroadcastReceiver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">//从服务器上获取数据</span></span><br><span class="line">                ......</span><br><span class="line">                runOnUiThread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="comment">//将获取的数据展示在界面上</span></span><br><span class="line">                        ......</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到这段代码，不知道你何感想，反正我是看着很不爽，缩进层次太多，完全违反了Clean Code的原则。那使用EventBus来实现又是什么样呢？我们看一下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEventBackgroundThread</span><span class="params">(MessageEvent messageEvent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//从服务器上获取数据</span></span><br><span class="line">    ......</span><br><span class="line">    EventBus.getDefault().post(<span class="keyword">new</span> ShowMessageEvent());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEventMainThread</span><span class="params">(ShowMessageEvent showMessageEvent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//将获取的数据展示在界面上</span></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对比一下以上两段代码就能很明显的感觉到EventBus的优势，代码简洁、层次清晰，大大提高了代码的可读性和可维护性。我这只是简单的加了一个小需求而已，随着业务越来越复杂，使用EventBus的优势愈加明显。</p><h2 id="常用API介绍"><a href="#常用API介绍" class="headerlink" title="常用API介绍"></a>常用API介绍</h2><h3 id="onEventXXX系列事件"><a href="#onEventXXX系列事件" class="headerlink" title="onEventXXX系列事件"></a>onEventXXX系列事件</h3><p>在上面我们已经接触到了EventBus的几个onEventXXX系列方法了。那他们有什么区别呢？  </p><p>在EventBus中的观察者通常有四种事件处理函数，分别是onEvent、onEventMainThread、onEventBackground与onEventAsync。</p><ul><li>onEvent：如果使用onEvent作为事件处理函数，那么该事件在哪个线程发布出来的，onEvent就会在这个线程中运行，也就是说发布事件和接收事件在同一个线程。在onEvent方法中尽量避免执行耗时操作，因为有可能会引起ANR。</li><li>onEventMainThread：如果使用onEventMainThread作为事件处理函数，那么不论事件是在哪个线程中发布出来的，该事件处理函数都会在UI线程中执行。该方法可以用来更新UI，但是不能处理耗时操作。</li><li>onEvnetBackground：如果使用onEventBackgrond作为事件处理函数，那么如果事件是在UI线程中发布出来的，那么该事件处理函数就会在新的线程中运行，如果事件本来就是子线程中发布出来的，那么该事件处理函数直接在发布事件的线程中执行。</li><li>onEventAsync：使用这个函数作为事件处理函数，那么无论事件在哪个线程发布，该事件处理函数都会在新建的子线程中执行。</li></ul><p>为了验证以上四个方法，我写了个小例子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(MessageEvent messageEvent)</span> </span>&#123;</span><br><span class="line">   Log.e(<span class="string">"onEvent"</span>, Thread.currentThread().getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEventMainThread</span><span class="params">(MessageEvent messageEvent)</span> </span>&#123;</span><br><span class="line">    Log.e(<span class="string">"onEventMainThread"</span>, Thread.currentThread().getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEventBackgroundThread</span><span class="params">(MessageEvent messageEvent)</span> </span>&#123;</span><br><span class="line">    Log.e(<span class="string">"onEventBackgroundThread"</span>, Thread.currentThread().getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEventAsync</span><span class="params">(MessageEvent messageEvent)</span> </span>&#123;</span><br><span class="line">    Log.e(<span class="string">"onEventAsync"</span>, Thread.currentThread().getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分别使用上面四个方法订阅同一事件，打印他们运行所在的线程。首先我们在UI线程中发布一条MessageEvent的消息，看下日志打印结果是什么。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">findViewById(R.id.send).setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">           Log.e(<span class="string">"postEvent"</span>, Thread.currentThread().getName());</span><br><span class="line">           EventBus.getDefault().post(<span class="keyword">new</span> MessageEvent());</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;);</span><br></pre></td></tr></table></figure><p>打印结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2689</span>-<span class="number">2689</span>/com.lling.eventbusdemo E/postEvent﹕ main</span><br><span class="line"><span class="number">2689</span>-<span class="number">2689</span>/com.lling.eventbusdemo E/onEvent﹕ main</span><br><span class="line"><span class="number">2689</span>-<span class="number">3064</span>/com.lling.eventbusdemo E/onEventAsync﹕ pool-<span class="number">1</span>-thread-<span class="number">1</span></span><br><span class="line"><span class="number">2689</span>-<span class="number">2689</span>/com.lling.eventbusdemo E/onEventMainThread﹕ main</span><br><span class="line"><span class="number">2689</span>-<span class="number">3065</span>/com.lling.eventbusdemo E/onEventBackgroundThread﹕ pool-<span class="number">1</span>-thread-<span class="number">2</span></span><br></pre></td></tr></table></figure><p>从日志打印结果可以看出，如果在UI线程中发布事件，则onEvent也执行在UI线程，与发布事件的线程一致。onEventAsync执行在名字叫做pool-1-thread-1的新的线程中。onEventMainThread执行在UI线程。onEventBackgroundThread执行在名字叫做pool-1-thread-2的新的线程中。</p><p>我们再看看在子线程中发布一条MessageEvent的消息时，会有什么样的结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">findViewById(R.id.send).setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">               <span class="meta">@Override</span></span><br><span class="line">               <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                   Log.e(<span class="string">"postEvent"</span>, Thread.currentThread().getName());</span><br><span class="line">                   EventBus.getDefault().post(<span class="keyword">new</span> MessageEvent());</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;).start();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;);</span><br></pre></td></tr></table></figure><p>打印结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3468</span>-<span class="number">3945</span>/com.lling.eventbusdemo E/postEvent﹕ Thread-<span class="number">125</span></span><br><span class="line"><span class="number">3468</span>-<span class="number">3945</span>/com.lling.eventbusdemo E/onEvent﹕ Thread-<span class="number">125</span></span><br><span class="line"><span class="number">3468</span>-<span class="number">3945</span>/com.lling.eventbusdemo E/onEventBackgroundThread﹕ Thread-<span class="number">125</span></span><br><span class="line"><span class="number">3468</span>-<span class="number">3946</span>/com.lling.eventbusdemo E/onEventAsync﹕ pool-<span class="number">1</span>-thread-<span class="number">1</span></span><br><span class="line"><span class="number">3468</span>-<span class="number">3468</span>/com.lling.eventbusdemo E/onEventMainThread﹕ main</span><br></pre></td></tr></table></figure><p>从日志打印结果可以看出，如果在子线程中发布事件，则onEvent也执行在子线程，与发布事件的线程一致（都是Thread-125）。onEventBackgroundThread也与发布事件在同一线程执行。onEventAsync则在一个名叫pool-1-thread-1的新线程中执行。onEventMainThread还是在UI线程中执行。</p><p>上面一个例子充分验证，onEventXXX系列方法执行所在的线程。</p><h2 id="黏性事件"><a href="#黏性事件" class="headerlink" title="黏性事件"></a>黏性事件</h2><p>除了上面讲的普通事件外，EventBus还支持发送黏性事件。何为黏性事件呢？简单讲，就是在发送事件之后再订阅该事件也能收到该事件，跟黏性广播类似。具体用法如下：</p><p>订阅黏性事件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EventBus.getDefault().registerSticky(StickyModeActivity.<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><p>发送黏性事件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EventBus.getDefault().postSticky(<span class="keyword">new</span> MessageEvent(<span class="string">"test"</span>));</span><br></pre></td></tr></table></figure><p>处理消息事件以及取消订阅和上面方式相同。</p><p>看个简单的黏性事件的例子，为了简单起见我这里就在一个Activity里演示了。</p><p>Activity代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StickyModeActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_sticky_mode);</span><br><span class="line">        findViewById(R.id.post).setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                EventBus.getDefault().postSticky(<span class="keyword">new</span> MessageEvent(<span class="string">"test"</span> + index++));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        findViewById(R.id.regist).setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                EventBus.getDefault().registerSticky(StickyModeActivity.<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        findViewById(R.id.unregist).setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                EventBus.getDefault().unregister(StickyModeActivity.<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(MessageEvent messageEvent)</span> </span>&#123;</span><br><span class="line">        Log.e(<span class="string">"onEvent"</span>, messageEvent.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEventMainThread</span><span class="params">(MessageEvent messageEvent)</span> </span>&#123;</span><br><span class="line">        Log.e(<span class="string">"onEventMainThread"</span>, messageEvent.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEventBackgroundThread</span><span class="params">(MessageEvent messageEvent)</span> </span>&#123;</span><br><span class="line">        Log.e(<span class="string">"onEventBackgroundThread"</span>, messageEvent.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEventAsync</span><span class="params">(MessageEvent messageEvent)</span> </span>&#123;</span><br><span class="line">        Log.e(<span class="string">"onEventAsync"</span>, messageEvent.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码很简单，界面上三个按钮，一个用来发送黏性事件，一个用来订阅事件，还有一个用来取消订阅的。首先在未订阅的情况下点击发送按钮发送一个黏性事件，然后点击订阅，会看到日志打印结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">15246</span>-<span class="number">15246</span>/com.lling.eventbusdemo E/onEvent﹕ test0</span><br><span class="line"><span class="number">15246</span>-<span class="number">15391</span>/com.lling.eventbusdemo E/onEventAsync﹕ test0</span><br><span class="line"><span class="number">15246</span>-<span class="number">15246</span>/com.lling.eventbusdemo E/onEventMainThread﹕ test0</span><br><span class="line"><span class="number">15246</span>-<span class="number">15393</span>/com.lling.eventbusdemo E/onEventBackgroundThread﹕ test0</span><br></pre></td></tr></table></figure><p>这就是粘性事件，能够收到订阅之前发送的消息。但是它只能收到最新的一次消息，比如说在未订阅之前已经发送了多条黏性消息了，然后再订阅只能收到最近的一条消息。这个我们可以验证一下，我们连续点击5次POST按钮发送5条黏性事件，然后再点击REGIST按钮订阅，打印结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6980</span>-<span class="number">6980</span>/com.lling.eventbusdemo E/onEvent﹕ test4</span><br><span class="line"><span class="number">6980</span>-<span class="number">6980</span>/com.lling.eventbusdemo E/onEventMainThread﹕ test4</span><br><span class="line"><span class="number">6980</span>-<span class="number">7049</span>/com.lling.eventbusdemo E/onEventAsync﹕ test4</span><br><span class="line"><span class="number">6980</span>-<span class="number">7048</span>/com.lling.eventbusdemo E/onEventBackgroundThread﹕ test4</span><br></pre></td></tr></table></figure><p>由打印结果可以看出，确实是只收到最近的一条黏性事件。</p><p>好了，EventBus的使用暂时分析到这里。下一讲将讲解EventBus的源码。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前言：EventBus出来有一段时间了，github上面也有很多开源项目中用到&lt;br&gt;了EventBus。所以抽空学习顺便整理了一下。&lt;/p&gt;
&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h
      
    
    </summary>
    
      <category term="移动开发" scheme="http://blogliu.com.cn/categories/%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="EventBus" scheme="http://blogliu.com.cn/tags/EventBus/"/>
    
      <category term="Android" scheme="http://blogliu.com.cn/tags/Android/"/>
    
      <category term="GitHub" scheme="http://blogliu.com.cn/tags/GitHub/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://blogliu.com.cn/posts/4a17b156/"/>
    <id>http://blogliu.com.cn/posts/4a17b156/</id>
    <published>2016-01-09T10:38:09.000Z</published>
    <updated>2018-11-23T08:40:17.389Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
