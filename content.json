{"meta":{"title":"刘腾的博客","subtitle":"攻城狮的博客","description":"一个低调的移动端开发工程师，前端工程师，UI设计师","author":"Liu Teng","url":"http://blogliu.com.cn"},"pages":[{"title":"404","date":"2018-11-22T04:16:22.171Z","updated":"2016-01-11T14:15:58.000Z","comments":false,"path":"404.html","permalink":"http://blogliu.com.cn/404.html","excerpt":"","text":""},{"title":"书单","date":"2018-11-23T06:57:35.448Z","updated":"2018-11-23T06:57:35.447Z","comments":false,"path":"books/index.html","permalink":"http://blogliu.com.cn/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2018-11-23T06:53:04.521Z","updated":"2018-11-23T06:53:04.521Z","comments":false,"path":"categories/index.html","permalink":"http://blogliu.com.cn/categories/index.html","excerpt":"","text":""},{"title":"关于","date":"2018-11-22T04:16:22.239Z","updated":"2017-01-16T02:28:08.000Z","comments":false,"path":"about/index.html","permalink":"http://blogliu.com.cn/about/index.html","excerpt":"","text":"Nickname: sdnuliuEmail: sdnuliu@qq.com 微信扫一扫，叫我好友"},{"title":"友情链接","date":"2018-11-23T07:12:38.622Z","updated":"2018-11-23T07:12:38.622Z","comments":true,"path":"links/index.html","permalink":"http://blogliu.com.cn/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2018-11-23T06:55:47.990Z","updated":"2018-11-23T06:55:47.990Z","comments":false,"path":"repository/index.html","permalink":"http://blogliu.com.cn/repository/index.html","excerpt":"","text":"Githubgithub: username: sdnuliu github username"},{"title":"标签","date":"2018-11-23T06:54:02.672Z","updated":"2018-11-23T06:54:02.670Z","comments":false,"path":"tags/index.html","permalink":"http://blogliu.com.cn/tags/index.html","excerpt":"","text":""},{"title":"留言","date":"2018-11-22T04:16:22.250Z","updated":"2016-12-10T04:32:24.000Z","comments":true,"path":"guestbook/index.html","permalink":"http://blogliu.com.cn/guestbook/index.html","excerpt":"","text":"欢迎大家给我留言，一起交流！"}],"posts":[{"title":"Android群英传读书笔记系列（二）","slug":"Android群英传读书笔记系列（二）","date":"2017-01-18T07:29:23.000Z","updated":"2018-11-23T08:40:17.400Z","comments":true,"path":"posts/cddb9e34/","link":"","permalink":"http://blogliu.com.cn/posts/cddb9e34/","excerpt":"","text":"Android群英传读书笔记记录，备忘，关于一些知识点以及重要的地方。 1. Android Scroll分析关键词：绝对坐标与视图坐标的区别 1.1. Android坐标系在Android中，是以屏幕的左上角作为坐标系的原点，向右是x轴，向下是Y轴。 系统提供了getLocationOnScreen(int locaiton[]) 获取坐标系位置，另外触控事件中getRawX() ,getRawY()获取的同样是Android坐标系中的坐标。 1.2 视图坐标系关于方向与1.1坐标系是一致的，只不过视图坐标系中，一个view的原点是以父视图坐上角为坐标原点。触控事件中getX() getY() 得到的就是视图坐标系中的坐标。 1.3 触控事件——MotionEvent1234567891011121314//单点触摸按下动作public static final int ACTION_DOWN=0;//单点触摸离开动作public static final int ACTION_UP=1;//触摸点移动动作public static final int ACTION_MOVE=2;//触摸点取消动作public static final int ACTION_CACEL=3;//触摸动作超出边界public static final int ACTION_OUTSIDE=4;//多点触摸按下动作public static final int ACTION_POINTER_DOWN=5;//多点离开动作public static final int ACTION_POINTER_UP=6; 1.4 实现滑动的七种方法1.4.1 layout()方法onTouchEvent()计算滑动距离，不断layout()，让view跟随手指滑动。 1.4.2 offsetLeftAndrRight()和offsetTopAndrBottom()系统提供的对上下、左右移动的封装，参数为偏移量 1234//同时对left和right进行偏移offsetLeftAndrRight(offsetX)//同时对top和bottom进行偏移offsetTopAndrBotton(offsetY) 1.4.3 LayoutParamsLayoutParams保存了一个view的参数，通过getLayoutParams()获取，然后进行修改 1234LinearLayout.LayoutParams layoutParams=(LinearLayout.LayoutParams)getLayoutParams();layoutParams.leftMargin=getLeft()+offsetX;layoutParams.topMargin=getTop()+offsetY;setLayoutParams(layoutParams); 或者 1234ViewGroup.MarginLayoutParms layoutParams=(ViewGroup.MarginLayoutParams)getLayoutParms();layoutParms.leftMargin=getLeft()+offsetX();layoutParms.topMargin=getTop()+offsetY();setLayoutParams(layoutParms); 1.4.4 scrollTo与scrollByscrollTo移动到某个位置，scrollBy移动某个增量。 关键点：viewgroup中 移动的是子view,view中，移动的是view中的内容。 移动方向问题，反向移动，可以理解为：view未动，移动的是屏幕 1.4.5 Scroller实现平滑滚动 三个步骤： 初始化Scroller 12//初始化ScrollermScroller=new Scroller(context); 重写computeScroll()方法，实现模拟滑动 12345678910@Overridepublic void computeScroll()&#123; super.computeScroll(); //判断Scroller是否执行完毕 if(mScroller.computeScrollOffset())&#123; ((View)getParent()).scrollTo(mScroller.getCurrX(),mScroller.getCurrY()); //通过重绘不断调用computeScroll invalidate(); &#125;&#125; startScroll 开启模拟过程 1.4.6 属性动画1.4.7 ViewDragHelper 初始化ViewDragHelper 1mViewDragHelper=ViewDragHelper.create(this,callback); 拦截事件 12345678910@Overridepublic boolean onInterceptTouchEvent(MotionEvent ev) &#123; return mViewDragHelper.shouldInterceptTouchEvent(ev);&#125;@Overridepublic boolean onTouchEvent(MotionEvent event)&#123; //将触摸事件传递给ViewDragHelper,此操作必不可少 mViewDragHelper.processTouchEvent(event);&#125; 处理computeScroll() 模板写法 123456@Overridepublic void computeScroll()&#123; if(mViewDragHelper.continueSetting(true))&#123; ViewCompat.postInvalidateOnAnimation(this); &#125;&#125; 处理回调Callback 123456private ViewDragHelper.Callback callback=new ViewDragHelper.Callback()&#123;@Overrridepublic boolean tryCaptureView(View child,int pointerId)&#123; return false;//根据具体需求修改&#125;&#125; 滑动方法 clampViewPositionVertical() clampViewPositionHorizontal() 2.Android 绘图机制与处理技巧2.1屏幕的尺寸信息2.1.1 屏幕参数 屏幕大小 对角线长度 分辨率 手机屏幕像素点个数 PPI Android使用mdpi(密度值为160)的屏幕作为标准，在这个屏幕上1px=1dp.其他屏幕按比例换算。 mdpi 1dp=1px hdpi 1dp=1.5px xhdpi 1dp=2px xxhdpi 1dp=3px 2.2 2D绘图基础paint属性 setAntiAlias() //设置画笔的锯齿效果 setColor() //设置画笔的颜色 setARGB() //设置画笔的ARGB值 setAlpha() //设置画笔的Alpha值 setTextSize() //设置字体的尺寸 setStyle() //设置画笔的风格 setStrokeWidth() //设置空心边框的宽度 2.2.1 canvas 绘图API DrawPonit 绘制点 canvas.drawPoint(x,y,paint) DrawLine 绘制直线 canvas.drawLine(startX,startY,endX,endY,paint) DrawLines 绘制多条直线 12floast[] pts=&#123;startX1,startY1,endX1,endY1,...&#125;canvas.drawLines(pts,ponit) DrawRect 绘制矩形 canvas.drawRect(left,top,right,bottom,paint) DrawRoundRect 绘制圆角矩形 canvas.drawRoundRect(left,top,bottom,raidusX,radiuxY,paint) DrawCircle 绘制圆 canvas.drawCircle(circleX,circleY,radius,paint) DrawArc 绘制弧形，扇形 12paint.setStyle(Paint.Style.STROKE);canvas.drawArc(left,top,right,bottom,startAngle,sweepAngle,userCenter,paint) DarwOval 绘制椭圆 canvas.drawOval(left,top,right,bottom,paint) DrawText 绘制文本 canvas.drawText(text,startX,startY,paint) DrawPosText 在指定位置绘制文本 canvas.drawPosText(text,new float[]{X1,Y1,X2,Y2,…Xn,Yn}) DrawPath 绘制路径 123456Path path=new Path();path.moveTo(50,50);path.lineTo(100,100);path.lineTo(100,300);path.lineTo(300,50);canvas.drawPath(path,paint); 2.3 Android Xml绘图2.3.1 bitmapsrc引用 2.3.2 Shape注意：shape支持的参数 2.3.3 Layer图层示例： 12345678910&lt;?xml version=\"1.0\" encoding=\"utf-8\"&gt;&lt;layer-list xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;item android:drawable=\"@drawable/ic_launcher\"/&gt; &lt;item android:drawable=\"@drawable/ic_launcher\" android:left=\"10.0dip\" android:top=\"10.0dip\" android:right=\"10.0dip\" android:bottom=\"10.0dip\"/&gt;&lt;/layer-list&gt; 2.3.4 selector主要实现不同效果 selector中可以组合使用shape 2.4 Android 绘图技巧2.4.1 canvasCanvas，几个非常有用的方法 Canvas.save() Canvas.restore() Canvas.translate() Canvas.rotate() save 保存画布，让后续操作就像在一个新的图层上操作一样 restore 合并图层，save之后的所有图像与save之前的图像合并 translate 坐标系的平移 rotate 也可以理解为坐标系的翻转 可以利用rotate画布的旋转和translate坐标系的平移实现一些复杂的效果 2.4.2 Layer图层通过saveLayer()方法 saveLayerAlpha()方法将一个图层入栈，使用restore()方法 restoreToCount()方法将一个图层出栈。 出栈的时候，会把图像绘制到上层Canvas上。 2.5 Android 图像处理之色彩特效处理2.5.1 色彩矩阵分析 色调–物体传播的颜色 饱和度–颜色的纯度 从0到100% 亮度–颜色的相对明暗程度 颜色矩阵 ColorMatrix 这块比较复杂，专门写一篇文章，这里跳过 2.6 Android图像处理之画笔特效处理2.6.1 PorterDuffXfermode控制两个图像的混合显示模式 dst 是先画的图形 src是后画的图形 最常用的是通过DST_IN SRC_IN实现将一个矩形图片变成圆角图片或者圆形图片的效果 123456789 mBitmap=BitmapFactory.decodeResouce(getResources(),R.drawable.test1); mOut=Bitmap.createBitamp(mBitmap.getWidth(),mBitmap.getHeight(),Bitmap.Config.ARGB_8888); Canvas canvas=new Canvas(mOut); mPaint =new Paint(); mPaint.setAntiAlias(true);canvas.drawRoundRect(0,0,mBitmap.getWidth(),mBitmap.getHeight(),80,80,mPaint);mPaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC_IN));canvas.drawBitmap(mBitmap,0,0,mPaint); 2.7 SurfaceView2.7.1 surfaceView与view view主要用于主动更新的情况下，surfaceView主要适用于被动更新，例如频繁的刷新 view在主线程中对画面进行刷新，surfaceView通过一个子线程进行页面的刷新 view在绘图时没有使用双缓冲机制，surfaceView在底层实现机制中就已经实现了双缓冲机制 2.7.2 创建一个surfaceview的模板 创建SurfaceView 创建自定义的SurfaceView继承自SurfaceView,并实现两个接口-SurfaceHolder.Callback和Runnable 1public class SurfaceViewTemplate extends SurfaceView implements SurfaceHolder.Callback,Runnable 初始化SurfaceView 在自定义surfaceview中，通常需要定义三个成员变量 123456//SurfaceHolderprivate SurfaceHolder mHolder;//用于绘图的Canvasprivate Canvas mCanvas;//子线程标志位private boolean mIsDrawing; 初始化方法就是对surfaceholder进行初始化 12mHolder=getHolder();mHolder.addCallback(this); 使用surfaceview 在surfaceCreated()方法中开启子线程进行绘制，在子线程使用一个while（mIsDrawing）的循环不停进行绘制，通过lockCanvas()方法获得的Canvas对象进行绘制，通过unlockCanvasAndPost(mCanvas)方法对画布内容进行提交。 模板代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class SurfaceViewTemplate extends SurfaceView implements SurfaceHolder.Callback,Runnable&#123;private SurfaceHolder mHolder;private Canvas mCanvas;private boolean mIsDrawing;public SurfaceViewTemplate(Context context)&#123; super(context); initView();&#125;public SurfaceViewTemplate(Context context,AttributeSet attrs)&#123; super(context,attrs); initView();&#125;public SurfaceViewTemplate(Context context,AttributeSet attrs,int defStyle)&#123; super(context,attrs,defStyle); initView();&#125;private void initView()&#123; mHolder=getHolder(); mHolder.setCallback(this); setFocusable(true); setFocusableInTouchMode(true); this.setKeepScreenOn(true);&#125;@Overridepublic void surfaceCreate(SurfaceHolder holder)&#123; mIdDrawing=true; new Thread(this).start();&#125;@Overridepublic void surfaceChanged(SurfaceHolder holder,int format, int width,int height)&#123;&#125;@Overridepublic void surfaceDestroyed(SurfaceHolder holder)&#123; mIdDrawing=false;&#125;@Overridepublic void run()&#123; while(mIdDrawing)&#123; draw(); &#125;&#125;private void draw()&#123; try&#123; mCanvas=mHolder.lockCanvas(); //draw something &#125; catch(Exception e)&#123; &#125; finally&#123; if(mCanvas!=null)&#123; mHolder.unlockCanvasAndPost(mCanvas); &#125; &#125;&#125;&#125;","categories":[{"name":"Android","slug":"Android","permalink":"http://blogliu.com.cn/categories/Android/"}],"tags":[{"name":"读书","slug":"读书","permalink":"http://blogliu.com.cn/tags/读书/"},{"name":"笔记","slug":"笔记","permalink":"http://blogliu.com.cn/tags/笔记/"}]},{"title":"工作以来的一些感悟","slug":"工作以来的一些感悟","date":"2017-01-16T02:15:26.000Z","updated":"2018-11-23T08:40:17.395Z","comments":true,"path":"posts/5e1364b0/","link":"","permalink":"http://blogliu.com.cn/posts/5e1364b0/","excerpt":"","text":"还是有很多感同身受的地方 原文作者：张明云 原文链接：http://zmywly8866.github.io/2016/04/05/job-experiences-in-last-years.html 养成良好的工作习惯（设计、代码质量、编码习惯、程序自测、版本管理等），有益于你的整个职业生涯； 迷茫的时候，做好手头上的事情； 脑力上的勤奋比体力上的勤奋重要很多倍，多思考； 危机感是让你持续前进的动力； 不能只靠经验去解决问题，要尽早形成一套属于自己的解决问题的方法； 不能为了快而牺牲质量，没搞定的事情迟早需要搞定，没弄明白的东西迟早需要弄明白，还不如一次性搞定； 最能提高工作效率的方式是工作不要返工； 生病了就要治，不要硬抗； 尽早考驾照，至于原因：你这辈子肯定会买车和买房吧； 不要为了省钱而降低生活质量，比如买二手物品、便宜的手机等，这些东西会给你带来持续的烦恼（就拿便宜的手机来讲：耗电、信号差、容易出问题，任何一件事情都能烦死你），会大大降低你的生活质量； 自信很重要，有了自信工作中没有什么问题是解决不了的； 学习的最好方式，是将自己的理解表达出来，可以是写作，也可以是帮助他人解决问题； 如果一件事情你花一个小时还没有思路，应该考虑寻求帮助，比如问同事、在社区中找答案、或者通过搜索引擎来解决； 搜索引擎尽量使用谷歌，至于原因：你用了就知道了； 书一定要看，书中的内容成体系，能够扩展你的视野，如果是要深入某一个知识点，阅读技术博客和源码更有价值； 有现成的轮子，就没必要再造一个同样的轮子，能用开源项目的尽量用开源项目； 网上的很多观点只能作为参考，不要过于迷信，有很多信息都只是告诉你结果，不会告诉你原因，或者有些结果是和环境有关的（比如不同API版本的AsyncTask实现原理不一样）；还有只说优点不说缺点（比如Chrome插件多、体验好，但占内存；Genymotion确实快，但不支持arm架构的so等）；所以很多东西需要自己实践之后才能得出结论，不然随意发表观点只会被别人笑话； 过早的优化是万恶之源； 工作忙的时候容易有情绪，此种情况下不要随意发表观点，甚至少说话，不然事后你多半会后悔； 出色的工作是在工作中有创造性，而不仅仅是一个执行者，简单来讲就是工作不仅仅要做完，还要做好，但做好很难； 不要为了哪门语言好、哪个工具棒去和别人争论，真的是浪费时间； 你必须承认人与人之间确实存在差距，横向比较可以是动力，但不能因此有负面情绪，没有意义； 作为团队的leader，想方设法发挥团队最大的价值，不要任何事情都亲力亲为，你的工作内容是给大家解决问题，想方设法提高大家的工作效率（比如持续集成、体力工作自动化、找趁手的工具、优化流程等）； 不到万不得已，不要因为工作做不完而去招人，工作是永远忙不完的，应该是根据团队的短板去招对应的人（差哪方面的人才就找哪方面的人才）； 评估工作量的时候，给出的时间至少是心里预期的2倍以上，不然最终坑的还是自己； 工作上并不是任何事情都需要通过技术手段来解决，技术投入大的可以和产品沟通，在能够达到同样效果的前提下，优化产品的交互。","categories":[{"name":"Android","slug":"Android","permalink":"http://blogliu.com.cn/categories/Android/"}],"tags":[{"name":"生活","slug":"生活","permalink":"http://blogliu.com.cn/tags/生活/"},{"name":"随笔","slug":"随笔","permalink":"http://blogliu.com.cn/tags/随笔/"}]},{"title":"Android群英传读书笔记系列（一）","slug":"Android群英传读书笔记系列（一）","date":"2017-01-15T01:33:41.000Z","updated":"2018-11-23T08:40:17.387Z","comments":true,"path":"posts/fdcd72ec/","link":"","permalink":"http://blogliu.com.cn/posts/fdcd72ec/","excerpt":"","text":"Android群英传读书笔记记录，备忘，关于一些知识点以及重要的地方。 1.Android体系与系统架构1.1Android体系大致分为四层：Linux内核层、库和运行时、Framework层和应用层。Android的体系架构鼓励系统组件重用，共享组件间的数据，并且定义组件间的访问权限控制。可以说这些层次结构既是相互独立，又是相互关联的。 1.1.1 Linux层Linux层包含系统的核心服务，包括硬件驱动，进程管理，系统安全等。 1.1.2 Dalvik和ART5.0之前 每个APP都会分配Dalvik，运行时编译；5.0之后，ART取代了Dalvik,安装时编译，运行时就不用编译了。 1.2组件架构关键词：协同工作，信使Intent 1.2.1 应用运行上下文对象创建Context的时间点： 创建Application 创建Activity 创建service 1.3 Android系统源代码目录与系统目录1.3.1 系统源代码目录可查看源码的网站：http://www.androidxref.com 1.3.2 Android系统目录 /system/app 系统app /system/bin Linux自带组件 /system/build.prop 系统属性信息 /system/fonts/ 系统字体 /system/framework 系统核心文件、框架层 /system/lib/ 共享库（.so） /system/media/ 系统提示音，系统铃声 /system/usr/ 用户的配置文件 /data/app 用户的大部分数据信息 /data/data app数据信息，报名区分 /data/system 手机的各项系统信息 /data/misc wifi、VPN信息 2.Android开发工具关键词：Android studio镜像网站：http://www.androiddevtools.cn/ 2.1 导入项目中的问题导入项目的gradle版本与本地不一致时，会去下载新的gradle版本，导致界面卡住。解决办法：先用本地gradle创建一个新的项目，然后将项目中的gradle文件夹和build.gradle文件替换要导入项目中的对应文件夹和文件，重新编译。 2.2 adb常用命令 adb install 安装应用 adb push 推送文件 需指定目录 adb pull 从手机获取文件 命令来源：\\system\\core\\toolbox 和 \\frameworks\\base\\cmds 3.Android控件架构和自定义控件viewGroup和view 两大类 3.1 Android界面架构图3.1.1 标准视图树的建立过程每个activity都包含一个window对象，这个对象通常是由phonewindow来实现的。phonewindow将decorview作为整个应用窗口的根view。DecorView作为窗口界面的顶层视图，封装了一些窗口操作的通常方法。在显示上，它将窗口分为两部分，一个是TitleView,一个是ContentView,ContentView是一个id为content的framelayout ,activity_main.xml就是设置在这个framelayout里。 3.2 View的测量Android通过提供MeasureSpec类，帮助我们测量view.MeasureSpec是一个32位的int值，高2位为测量的模式，低30位为测量的大小。 3.2.1 测量模式 EXACTLY—精确值模式，指定大小 AT_MOST—最大值模式，wrap_content UNSPECIFIED—不指定模式，想多大多大，一般用在自定义view View默认onMeasure只支持EXACTLY模式，自定义view可以通过重写onMeasure()方法进行修改。 源码可以发现系统最终调用setMeasuredDimension()方法将测量后的宽高设置进去，所以在重写onMeasure方法时，需要将测量后的宽高值作为参数设置给setMeasureDimension()方法。 123protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec)&#123; setMeasuredDimension(measureWidth(widthMeasureSpec),measureHeight(heightMeasureSpec));&#125; 关于measureWidth方法 1234567891011121314private int measureWidth(int measureSpec)&#123; int result=0; int specMode=MeasureSpec.getMode(measureSpec); int specSize=MeasureSpec.getSize(measureSpec); if(specMode==MeasureSpec.EXACTLY)&#123; result=specSize; &#125;else&#123; result=200; if(specMode==MeasureSpec.AT_MOST)&#123; result=Math.min(result,specSize); &#125; &#125; return result;&#125; 3.3 View的绘制关键词：onDraw() 对Canvas的理解：new Canvas时一般会传入一个bitmap对象，view的绘制是在bitmap上进行的绘制。 3.4 自定义ViewView中比较重要的一些回调方法： onFinishInflate() xml加载组件后回调 onSizeChanged() 组件大小改变时回调 onMeasure() 回调该方法用来测量 onLayout() 回调该方法确定显示位置 onTouchEvent() 监听到触摸事件时回调 3.4.1 自定义控件三种方式 对现有控件进行扩展 通过组合实现新的控件 重写view实现全新的控件 3.4.2 为view添加自定义属性在res资源目录的values目录下创建attrs.xml的属性定义文件（多属性的时候，在format里通过”|”区别，例:reference|color） 1.typeArray获取完值之后，要调用recycle()方法避免重新创建时的错误。 3.4.3 引用ui模板引入自定义的命名空间xmlns:custom=”http://schemes.android.com/apk/res_auto&quot; custom为命名空间的名字，可自定义。 3.4.4 绘制圆弧【基本语法】 1public void drawArc (RectF oval, float startAngle, float sweepAngle, boolean useCenter, Paint paint) 参数说明 oval：圆弧所在的椭圆对象。 startAngle：圆弧的起始角度。 sweepAngle：圆弧的角度。 useCenter：是否显示半径连线，true表示显示圆弧与圆心的半径连线，false表示不显示。 paint：绘制时所使用的画笔。 3.4.5 自定义ViewGroup通常重写onMeasure()方法对子view进行测量，重写onLayout()方法确定子view的位置，重写onTouchEvent()方法增加响应事件。 3.4.6 事件分发关键三个方法： dispatchTouchEvent(MotionEvent ev) onInterceptTouchEvent(MotionEvent ev) true拦截false不拦截 onTouchEvent(MotionEvent ev) true处理(不再往上传递)false不处理 4.ListView的使用技巧备注:目前recycleview用的比较多 4.1 使用ViewHolder模式提高效率可以提高50%以上 4.2 ListView的分割线android:divider android:dividerHeight android:divider=”@null” 可以将分割线设置成透明 4.3 隐藏listview的滚动条android:scrollbars=”none” 4.4 取消listview的item的点击效果android:listSelector=”#00000000” 或者 android:listSeletor=”@android:color/transparent” 4.5 设置listview要显示在第几项listView.setSelection(N); 瞬间移动完成listView.smoothScrollBy(distance,duration)listView.smoothScrollByOffset(offset)listView.smoothScrollToPosation(index) 下面三个为平滑滚动 4.6 处理空listviewListView提供了一个方法setEmptyView(),通过这个方法可以给listview设置一个空数据下显示的默认提示 4.7 listview的滑动监听 onTouchListener onScrollListener","categories":[{"name":"Android","slug":"Android","permalink":"http://blogliu.com.cn/categories/Android/"}],"tags":[{"name":"读书","slug":"读书","permalink":"http://blogliu.com.cn/tags/读书/"},{"name":"笔记","slug":"笔记","permalink":"http://blogliu.com.cn/tags/笔记/"}]},{"title":"轻松搞定MarkDown","slug":"轻松搞定MarkDown","date":"2016-12-12T13:11:54.000Z","updated":"2018-11-23T08:40:17.398Z","comments":true,"path":"posts/aebfe40d/","link":"","permalink":"http://blogliu.com.cn/posts/aebfe40d/","excerpt":"","text":"Markdown是一种轻量级的标记语言，用简单的标记语法就可以达到排版的目的，可以使我们更加专注于内容的编写，而不用过多的关注排版。本文主要整理了Markdown中常用的标记语法，便于以后查用。 段落元素1.段落与换行Markdown中的段落指连续的一段文字，编写段落之间至少用一个空行隔开，段落内多个空格将被视为一个空格，段首不支持缩进。 如果想要在显示时显示多个空行，可以插入&lt;br/&gt;来实现,注意的是，插入的&lt;br/&gt;应与前后的段落中间至少空一行。 2.标题Markdown支持两种类型的标题。 1234567891011//类型1这是一级标题=============这是二级标题-------------//类型2# 这是一级标题## 这是二级标题...###### 这是六级标题 从上面个可以看出类型1是在标题下面插入=或者-来标识标题等级，但局限是其只能表示两个级别的标题。 类型2是在标题前面插入1-6个#，表示6个等级的标题，这是比较推荐的用法。 3.引用Markdown中使用 &gt; 来引用。我们可以在一段文字中的每行开头加上 &gt; 来表示一段引用文字，也可以只在一段文字的开头插入一个 &gt; 来表示，如下面的1、2两种方式： 1234567//方式1&gt; 这是一句话&gt; 这是第二句话//方式2&gt;这是一句话&gt;这是第二句话 Markdown支持使用不同数量的 &gt; 表示嵌套引用 12&gt;这是外层的引用&gt;&gt;这是内层的引用 效果如下: 这是外层的引用 这是内层的引用 4.无序列表无序列表使用 - 、+ 或 * 来作为标记。 123- 第一项- 第二项- 第三项 效果如下: 第一项 第二项 第三项 上面的-可以用+、*替换。需要注意的是，-等符号与后面的文字至少空一格空格。 5.有序列表有序列表使用数字和紧挨着的点号表示。 1231.第一项2.第二项3.第三项 同无序列表一样，标记符号与后面的文字至少空一格空格。但编辑时的数字对显示无影响。 效果如下: 第一项 第二项 第三项 第四项 列表 有序列表和无序列表的每一项中均可嵌套其他列表 在列表项之间要插入段落时，这时需要将列表项之间的段落缩进4个空格； 使用 1. 来输出 1. ； 6.代码区块缩进4个空格，需要注意的是，每行代码都需要至少缩进4个空格，不能像段落一样采用首行标记的偷懒写法，一个代码区会一直持续到没有缩进4个空格的那一行。 也可以用一对三个连续的 ` 来包裹代码段。 123``` Java System.out.println(&quot;HelloWorld&quot;);``` 效果如下: 1System.out.println(\"HelloWorld\"); 解释器可以根据代码的语言从而给代码加上语法高亮。 7.分割线使用三个及以上的*、-或_表示一个分割线，符号不能混用，符号之间可以插入多个空格。需要注意的是，使用-来插入分割线时需要与上一个段落至少空一行，否则Markdown会将上一行文字解释为二级标题。 8.表格表格是Markdown比较复杂的一种表示。 12345| Table | Col1 | Col2 || ----- | :---:| ----:|| Row1 | 1-1 | 1-2 || Row2 | 2-1 | 2-2 || Row3 | 3-1 | 3-2 | 效果如下: Table Col1 Col2 Row1 1-1 1-2 Row2 2-1 2-2 Row3 3-1 3-2 上面第二行中的点代表对齐方式，分别是默认（居左）、居中、居右。 行内元素9.超链接Markdown中有三种方式实现超链接。 123456//方式1[百度](http://www.baidu.com)//方式2[百度][Baidu-url][Baidu-url]: http://www.baidu.com 效果如下： 百度 [百度][Baidu-url][Baidu-url]: http://www.baidu.com 方式1较为常用，也可以为链接的文字加上提示文字，只要在括号中超链接加上空格后添加提示内容即可。 1[百度](http://www.baidu.com &quot;这是提示文字&quot;) 效果如下: 百度 第三种方式是用 &lt;&gt; 来包裹URL. 12//方式3&lt;http://www.baidu.com&gt; 效果如下：http://www.baidu.com ###加粗与斜体 Markdown使用*和_来表示粗体和斜体。 1234567//加粗**这是加粗文字**__这也是加粗文字__//斜体*这是斜体文字*_这也是斜体文字_ 效果如下： 这是加粗文字 这也是加粗文字 这是斜体文字 这也是斜体文字 被偶数个*或_包裹的文字显示为加粗效果，被奇数个包裹的为倾斜效果。 需要注意的是，*和_是成对出现，不能混合使用，也不能只出现一个。同时，标识符号要与标识的文字紧挨着，符号和符号之间、符号文字之间不能有任何空格。 11.代码使用`来包裹一小段代码。 1`Hello World` 效果如下： Hello World 若想要在代码中添加撇号，可以使用多个撇号包裹里面需要添加的撇号，但注意里面的连续的撇号数量不能超过外面的数量。 1234//显示一个撇号`` ` ``//显示两个撇号``` `` ``` 效果如下： //显示一个撇号 ` //显示两个撇号 1`` 12.图片图片的插入方式跟超链接前两种方式类似。 123456//方式1![如果图片不能显示，就显示这段文字](图片 url)//方式2![如果图片不能显示，就显示这段文字][Image-url][Image-url]: 图片url &quot;这是提示文字&quot; 效果如下: ![][Image-url][Image-url]: 图片url “这是提示文字” 反斜杠 \\我们经常需要在文章中插入一些特殊符号，而这些符号恰好是前面所讲的标识符号，可以在特殊符号前插入\\来直接显示符号，而不让Markdown来将其解释为标识符号。 Markdown支持以下这些符号前插入 而显示其本来样子： 123456789101112\\ 反斜线` 反引号* 星号_ 底线&#123;&#125; 花括号[] 方括号() 括弧# 井字号+ 加号- 减号. 英文句号! 感叹号 工具 Windows 环境下，推荐Typora 、Markdownpad Mac环境下，推荐 Mou 笔记软件：为知笔记较好的支持markdown，且支持Windows Mac Web IOS Android 各个平台 当然，还有Github 拓展阅读Markdown语法说明","categories":[{"name":"MarkDown","slug":"MarkDown","permalink":"http://blogliu.com.cn/categories/MarkDown/"}],"tags":[{"name":"编辑器","slug":"编辑器","permalink":"http://blogliu.com.cn/tags/编辑器/"},{"name":"MarkDown","slug":"MarkDown","permalink":"http://blogliu.com.cn/tags/MarkDown/"}]},{"title":"再会","slug":"再会","date":"2016-12-10T06:36:21.000Z","updated":"2018-11-23T08:40:17.392Z","comments":true,"path":"posts/209fe3d4/","link":"","permalink":"http://blogliu.com.cn/posts/209fe3d4/","excerpt":"","text":"http://www.blogitliu.com 一年前申请的域名，不知不觉已然是2016年最后的一个月了，好一个时光如梭，岁月无情。再不记载点什么一年又这么浑浑噩噩的消逝了。当然，即便写下千言万语，还是改变不了没什么进步的一年的残酷现实。京城的冬日里难得几天连续晴朗，让人的心情也光明了一些，然而刚刚暗自欣喜了一下，就看到了明天雾霾红色预警的新闻。。。 说说这个网站吧，其实折腾了也很久，早期弄Discuz社区，用的那个域名都不知道让自己扔哪个角落里去了，后来想写博客，就申请了新的域名，刚开始用WordPress 租的国外的空间，总是不稳定，再后来换了Hexo,Github的空间，省了很多事，技术折腾来折腾去，网站内容却没什么更新，总是做事情三分钟热度，所以很欣赏那些拥有好习惯的人，坚持去做一件事，真的是一种让人很是佩服的品质。就像博客标题里写的那样，再牛逼的梦想也抵不过傻逼一样的坚持。 周末还是做了点事情，把 网站 http://www.blogitliu.com 的评论留言系统进行了更新，之前的留言系统是disqus,国外的一个非常不错的评论系统，但是万恶的天朝哎，在国内被墙了，目前换成了多说，还不知道稳定性怎么样，欢迎没事的同学前来测个试什么的，电脑访问哦，手机优化的不是很好。 博客以后还是经常更新点东西吧，转载也好原创也好，万一哪天不作程序员了，是不是也可以去当个作家。。有时候脑子里总是会冒出各种千奇百怪的想法，就像书里写的那样“平行世界，多元生活，既可以朝九晚五，又能够浪迹天涯”，让人好生羡慕。 无论发生了什么，日子还是一样的过，生活还是一样要面对，一切都是命中注定。祝顺利，平安。","categories":[{"name":"心情随笔","slug":"心情随笔","permalink":"http://blogliu.com.cn/categories/心情随笔/"}],"tags":[{"name":"生活","slug":"生活","permalink":"http://blogliu.com.cn/tags/生活/"},{"name":"随笔","slug":"随笔","permalink":"http://blogliu.com.cn/tags/随笔/"}]},{"title":"说点什么","slug":"说点什么","date":"2016-08-03T03:13:25.000Z","updated":"2018-11-23T08:40:17.393Z","comments":true,"path":"posts/55640277/","link":"","permalink":"http://blogliu.com.cn/posts/55640277/","excerpt":"","text":"这个荒芜之地已接近半年没有更新过了，幸运的是它还一直健在。我也不知道为什么自从更新几次之后就再也没能有心情和动力在这里做点什么，尽管这么长时间里我的生活已经改变了许多，但在这里却一点也没有体现。之前的一段时间曾一度想就此关闭，不过应该鲜有人知道在那段时间里原来的域名指向的并不是这儿。不过后来还是没有舍得，索性就恢复了。还好一切还是原来的样子，所有的功能也都正常。 这半年我来到了新的公司，认识了新的人，开始了新的生活，但这并不意味着就和老朋友们再无瓜葛，而是仍有不少交集。其实正是前两天某个朋友说要弄域名的时候，才让我决定了要重新开垦这片土地。 时间经历变化很多，很多熟悉的人都有了新的归宿，有人难得浪子回头，有人开始浪迹天涯，有人依然浪人浪语，可惜没人锒铛入狱。总之，大家都有了新的开始。但这些开始也仅仅只是开始，半年的时间放在许多事情的完整历程当中，还是显得那么短暂。但愿人长久吧。 不知道如果我不动声色的话，现在的这些文字多久后才会被人不经意间看到。但是当你看到时，还请刻意回首一下这一年过去的时光，看看自己是否有所改变，是否记忆犹鲜，不过无论怎样，都愿我们前程似锦，气象万千。","categories":[{"name":"心情随笔","slug":"心情随笔","permalink":"http://blogliu.com.cn/categories/心情随笔/"}],"tags":[{"name":"生活","slug":"生活","permalink":"http://blogliu.com.cn/tags/生活/"},{"name":"随笔","slug":"随笔","permalink":"http://blogliu.com.cn/tags/随笔/"}]},{"title":"EventBus源码解读","slug":"EventBus源码解读","date":"2016-01-12T07:51:10.000Z","updated":"2018-11-23T08:40:17.404Z","comments":true,"path":"posts/71d27a28/","link":"","permalink":"http://blogliu.com.cn/posts/71d27a28/","excerpt":"","text":"之前写了EventBus的使用详解，下面来详细分析一下EventBus的源码吧。 转载相关博客：EventBus源码研读:http://kymjs.com/code/2015/12/16/01EXECUTORSERVICE线程池讲解：http://www.cnphp6.com/archives/61093EventBus源码解析:http://www.trinea.cn/android/eventbus-source-analysis/彻底理解ThreadLocal:http://blog.csdn.net/lufeng20/article/details/24314381 进入源码世界入口类EventBus类从使用的流程来看，首先是EventBus#getDefault() 12345678910public static EventBus getDefault()&#123; if(defaultInstance == null)&#123; synchronized(EventBus.class)&#123; if(defaultInstance == null)&#123; defaultInstance = new EventBus(); &#125; &#125; &#125; return defaultInstance;&#125; 可以看出是一个单例模式，调用构造方法，再看构造方法，调用一个重载的构造方法，重载的构造方法又需要一个EventBusBuilder对象。 123public EventBus() &#123; this(DEFAULT_BUILDER); &#125; 123EventBus(EventBusBuilder builder) &#123; ...... &#125; EventBusBuilder类这个类主要用来创建EventBus对象使用。包含的属性也是EventBus的一些参数设置，build函数用于新建EventBus对象,installDefaultEventBus函数将当前设置应用于Default EventBus。 12345678910111213141516public class EventBusBuilder &#123; private static final ExecutorService DEFAULT_EXECUTOR_SERVICE = Executors.newCachedThreadPool(); boolean logSubscriberExceptions = true; boolean logNoSubscriberMessages = true; boolean sendSubscriberExceptionEvent = true; boolean sendNoSubscriberEvent = true; boolean throwSubscriberException; boolean eventInheritance = true; ExecutorService executorService; List&lt;Class&lt;?&gt;&gt; skipMethodVerificationForClasses; EventBusBuilder() &#123; this.executorService = DEFAULT_EXECUTOR_SERVICE; &#125; ...... &#125; longSubscriberExceptions :当调用事件处理函数异常时是否打印异常信息，默认为truelongNoSubscriberMessages :没有订阅者订阅该事件时是否打印日志，默认为truesendSubscriberExceptionEvent :当调用事件处理函数异常时是否发送SubscriberExceptionEvent事件，如果此开关打开，订阅者可以通过 123public void onEvent(SubscriberExceptionEvent event&#123; ......&#125; 订阅该事件进行处理，默认为true. sendNoSubscriberEvent :如果没有订阅者，发送一条默认事件throwSubscriberException :当调用事件处理函数异常时是否抛出异常，默认为false,可通过12EventBus.builder().throwSubscriberException(true).installDefaultEventBus() 打开。eventInheritance :event的子类是否也能响应订阅者executorService :异步，BackGround处理方式的线程池 通过上面可以看出，EventBus.getDefault()方法会创建一个默认的EventBusBuilder，如果我们想修改EventBusBuilder的一些配置选项，可以通过EventBus.builder()方法生成一个EventBusBuidler,然后设置自定义配置选项，最后调用installDefaultEventBus方法创建一个EventBus对象。 1234567891011public EventBus installDefaultEventBus() &#123; Class var1 = EventBus.class; synchronized(EventBus.class) &#123; if(EventBus.defaultInstance != null) &#123; throw new EventBusException(\"Default instance already exists. It may be only set once before it\\'s used the first time to ensure consistent behavior.\"); &#125; else &#123; EventBus.defaultInstance = this.build(); return EventBus.defaultInstance; &#125; &#125; &#125; 三个Poster类分析完EventBusBuilder，再来看EventBus的构造方法。 123456789101112131415161718192021EventBus(EventBusBuilder builder) &#123; this.currentPostingThreadState = new ThreadLocal() &#123; protected EventBus.PostingThreadState initialValue() &#123; return new EventBus.PostingThreadState(); &#125; &#125;; this.subscriptionsByEventType = new HashMap(); this.typesBySubscriber = new HashMap(); this.stickyEvents = new ConcurrentHashMap(); this.mainThreadPoster = new HandlerPoster(this, Looper.getMainLooper(), 10); this.backgroundPoster = new BackgroundPoster(this); this.asyncPoster = new AsyncPoster(this); this.subscriberMethodFinder = new SubscriberMethodFinder(builder.skipMethodVerificationForClasses); this.logSubscriberExceptions = builder.logSubscriberExceptions; this.logNoSubscriberMessages = builder.logNoSubscriberMessages; this.sendSubscriberExceptionEvent = builder.sendSubscriberExceptionEvent; this.sendNoSubscriberEvent = builder.sendNoSubscriberEvent; this.throwSubscriberException = builder.throwSubscriberException; this.eventInheritance = builder.eventInheritance; this.executorService = builder.executorService; &#125; HandlerPoster、BackgroundPoster、AsyncPosterHandlerPoster:前台发送者BackgroundPoster:后台发送者AsyncPoster:后台发送者，只让队列的最后一个待订阅者去响应 每个Poster中都有一个任务队列，PendingPostQueuePendingPostQueue中定义了两个节点，队列的头节点和尾节点 12private PendingPost head; private PendingPost tail; PengdingPost类的实现： 1234567final class PendingPost &#123; private static final List&lt;PendingPost&gt; pendingPostPool = new ArrayList(); Object event; Subscription subscription; PendingPost next; ...... &#125; 首先提供了一个池的设计，类似于我们的线程池，目的是为了减少对象创建的开销，当一个对象不用了，我们可以留着它，下次再需要的时候返回这个保留的而不是再去创建。 1234567891011121314static PendingPost obtainPendingPost(Subscription subscription, Object event) &#123; List var2 = pendingPostPool; synchronized(pendingPostPool) &#123; int size = pendingPostPool.size(); if(size &gt; 0) &#123; PendingPost pendingPost = (PendingPost)pendingPostPool.remove(size - 1); pendingPost.event = event; pendingPost.subscription = subscription; pendingPost.next = null; return pendingPost; &#125; &#125; return new PendingPost(event, subscription);&#125; 上面的方法会检查线程池中是否有可复用的，如果有可用的，返回可复用对象，如果没有可复用的，创建一个新的PendingPost对象。 1234567891011static void releasePendingPost(PendingPost pendingPost) &#123; pendingPost.event = null; pendingPost.subscription = null; pendingPost.next = null; List var1 = pendingPostPool; synchronized(pendingPostPool) &#123; if(pendingPostPool.size() &lt; 10000) &#123; pendingPostPool.add(pendingPost); &#125; &#125;&#125; 上述方法回收PengingPost对象，为了防止池无线增长，增加了size&lt;1000的判断。 PendingPost分析完之后，我们看PendingPostQueue的出列和入列方式。 12345678910111213141516synchronized void enqueue(PendingPost pendingPost) &#123; if(pendingPost == null) &#123; throw new NullPointerException(\"null cannot be enqueued\"); &#125; else &#123; if(this.tail != null) &#123; this.tail.next = pendingPost; this.tail = pendingPost; &#125; else &#123; if(this.head != null) &#123; throw new IllegalStateException(\"Head present, but no tail\"); &#125; this.head = this.tail = pendingPost; &#125; this.notifyAll(); &#125; &#125; 首先是入列方式，tail尾的next指向当前正在入队的节点，tail指向自己（自己变成了最后一个节点），完成入队。如果是第一个元素，将head和tail都指向自己就可以了。 12345678910synchronized PendingPost poll() &#123; PendingPost pendingPost = this.head; if(this.head != null) &#123; this.head = this.head.next; if(this.head == null) &#123; this.tail = null; &#125; &#125; return pendingPost; &#125; pendingPost为要出队的节点，将head指向head的next，完成出队，如果只有一个元素，tail置空。 PendingPostQueue再往上一级，是HandlerPost的enqueue方法。 123456789101112void enqueue(Subscription subscription, Object event) &#123; PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event); synchronized(this) &#123; this.queue.enqueue(pendingPost); if(!this.handlerActive) &#123; this.handlerActive = true; if(!this.sendMessage(this.obtainMessage())) &#123; throw new EventBusException(\"Could not send handler message\"); &#125; &#125; &#125; &#125; 根据输入参数，生成待发送对象PendingPost,然后加入队列，如果此时handlerActive是false的话，发送一条空的消息激活handler,然后是handleMessage()方法 123456789101112131415161718192021222324252627282930313233public void handleMessage(Message msg) &#123; boolean rescheduled = false; try &#123; long started = SystemClock.uptimeMillis(); long timeInMethod; do &#123; PendingPost pendingPost = this.queue.poll(); if(pendingPost == null) &#123; synchronized(this) &#123; pendingPost = this.queue.poll(); if(pendingPost == null) &#123; this.handlerActive = false; return; &#125; &#125; &#125; this.eventBus.invokeSubscriber(pendingPost); timeInMethod = SystemClock.uptimeMillis() - started; &#125; while(timeInMethod &lt; (long)this.maxMillisInsideHandleMessage); if(!this.sendMessage(this.obtainMessage())) &#123; throw new EventBusException(\"Could not send handler message\"); &#125; rescheduled = true; &#125; finally &#123; this.handlerActive = rescheduled; &#125; &#125; handleMessage不停的去待发送队列queue中去取消息（timeInMehtod&lt;maxMillisInsideHandleMessage,加判断为了防止主线程ANR），最终通过eventBus的invokeSubscriber方法发送出去，让注册了的订阅者去响应。关于BackgroundPoster、AsyncPoster原理与HandlerPoster类似，这两个是工作在异步，实现Runnable接口，用到了ExecutorService。 Subscribe流程分析完EventBus的构造函数，下面看一下入口方法register(). 12345678private synchronized void register(Object subscriber, boolean sticky, int priority) &#123; List subscriberMethods = this.subscriberMethodFinder.findSubscriberMethods(subscriber.getClass()); Iterator var5 = subscriberMethods.iterator(); while(var5.hasNext()) &#123; SubscriberMethod subscriberMethod = (SubscriberMethod)var5.next(); this.subscribe(subscriber, subscriberMethod, sticky, priority); &#125;&#125; SubscriberMethod类从字面意思是订阅者方法，看看类中的方法 123456789101112131415161718final Method method; final ThreadMode threadMode; final Class&lt;?&gt; eventType; String methodString; SubscriberMethod(Method method, ThreadMode threadMode, Class&lt;?&gt; eventType) &#123; this.method = method; this.threadMode = threadMode; this.eventType = eventType; &#125; private synchronized void checkMethodString() &#123; if(this.methodString == null) &#123; StringBuilder builder = new StringBuilder(64); builder.append(this.method.getDeclaringClass().getName()); builder.append('#').append(this.method.getName()); builder.append('(').append(this.eventType.getName()); this.methodString = builder.toString(); &#125; &#125; Method：方法名ThreadMode:一个枚举类checkMehtodString()方法是为了设置变量methodString的值 SubscriberMethodFinder类subscriberMethodFinder类主要是通过反射的方法来判断传入的this对象中是否有onEvent开头的方法的。 1234567891011121314private void filterSubscriberMethods(List&lt;SubscriberMethod&gt; subscriberMethods, HashMap&lt;String, Class&gt; eventTypesFound, StringBuilder methodKeyBuilder, Method[] methods) &#123; for (Method method : methods) &#123; String methodName = method.getName(); if (methodName.startsWith(ON_EVENT_METHOD_NAME)) &#123; int modifiers = method.getModifiers(); Class&lt;?&gt; methodClass = method.getDeclaringClass(); if ((modifiers &amp; Modifier.PUBLIC) != 0 &amp;&amp; (modifiers &amp; MODIFIERS_IGNORE) == 0) &#123; ...... &#125; &#125; &#125; &#125; 通过对全部的方法遍历，为了效率首先做一次筛选，只关注我们的以 “onEvent” 开头的方法。 1234567891011121314151617181920private ThreadMode getThreadMode(Class&lt;?&gt; clazz, Method method, String methodName) &#123; String modifierString = methodName.substring(ON_EVENT_METHOD_NAME.length()); ThreadMode threadMode; if (modifierString.length() == 0) &#123; threadMode = ThreadMode.PostThread; &#125; else if (modifierString.equals(\"MainThread\")) &#123; threadMode = ThreadMode.MainThread; &#125; else if (modifierString.equals(\"BackgroundThread\")) &#123; threadMode = ThreadMode.BackgroundThread; &#125; else if (modifierString.equals(\"Async\")) &#123; threadMode = ThreadMode.Async; &#125; else &#123; if (!skipMethodVerificationForClasses.containsKey(clazz)) &#123; throw new EventBusException(\"Illegal onEvent method, check for typos: \" + method); &#125; else &#123; threadMode = null; &#125; &#125; return threadMode; &#125; 这里我们看到，其实EventBus不仅仅支持onEvent()的回调，它还支持onEventMainThread()、onEventBackgroundThread()、onEventAsync()这三个方法的回调。一直到最后，我们看到这个方法把所有的方法名集合作为value，类名作为key存入了 methodCache 这个全局静态变量中。意味着，整个库在运行期间所有遍历的方法都会存在这个 map 中，而不必每次都去做耗时的反射取方法了。 12synchronized(methodCache) &#123; methodCache.put(subscriberClass, subscriberMethods1); 123synchronized(methodCache) &#123; subscriberMethods = (List)methodCache.get(subscriberClass); &#125; 事件的处理与发送subscribe()subscribe()方法方法接收四个参数：订阅者封装的对象、响应方法名封装的对象、是否为粘滞事件、这条事件的优先级。 12345678910111213141516171819202122232425262728293031 // Must be called in synchronized block private void subscribe(Object subscriber, SubscriberMethod subscriberMethod, boolean sticky, int priority) &#123; Class&lt;?&gt; eventType = subscriberMethod.eventType; CopyOnWriteArrayList&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType); Subscription newSubscription = new Subscription(subscriber, subscriberMethod, priority); if (subscriptions == null) &#123; subscriptions = new CopyOnWriteArrayList&lt;Subscription&gt;(); subscriptionsByEventType.put(eventType, subscriptions); &#125; else &#123; if (subscriptions.contains(newSubscription)) &#123; throw new EventBusException(\"Subscriber \" + subscriber.getClass() + \" already registered to event \" + eventType); &#125; &#125; // Starting with EventBus 2.2 we enforced methods to be public (might change with annotations again) // subscriberMethod.method.setAccessible(true); int size = subscriptions.size(); for (int i = 0; i &lt;= size; i++) &#123; if (i == size || newSubscription.priority &gt; subscriptions.get(i).priority) &#123; subscriptions.add(i, newSubscription); break; &#125; &#125; List&lt;Class&lt;?&gt;&gt; subscribedEvents = typesBySubscriber.get(subscriber); if (subscribedEvents == null) &#123; subscribedEvents = new ArrayList&lt;Class&lt;?&gt;&gt;(); typesBySubscriber.put(subscriber, subscribedEvents); &#125; subscribedEvents.add(eventType); .......&#125; 每个订阅者是可以有多个重载的onEvent()方法的，所以这里多做了一步，将所有订阅者的响应方法保存到subscribedEvents中。 注：子事件也可以让响应父事件的 onEvent() 。这个有点绕，举个例子，订阅者的onEvent(CharSequence),如果传一个String类型的值进去，默认情况下是不会响应的，但如果我们在构建的时候设置了 eventInheritance 为 true ,那么它就会响应了。 post()方法调用流程1234567891011121314151617181920public void post(Object event) &#123; PostingThreadState postingState = currentPostingThreadState.get(); List&lt;Object&gt; eventQueue = postingState.eventQueue; eventQueue.add(event); if (!postingState.isPosting) &#123; postingState.isMainThread = Looper.getMainLooper() == Looper.myLooper(); postingState.isPosting = true; if (postingState.canceled) &#123; throw new EventBusException(\"Internal error. Abort state was not reset\"); &#125; try &#123; while (!eventQueue.isEmpty()) &#123; postSingleEvent(eventQueue.remove(0), postingState); &#125; &#125; finally &#123; postingState.isPosting = false; postingState.isMainThread = false; &#125; &#125;&#125; post() 方法首先从 currentPostingThreadState 对象中取了一个 PostingThreadState ，我们来看看这个 currentPostingThreadState 对象的创建代码。 1234567private final ThreadLocal&lt;PostingThreadState&gt; currentPostingThreadState = newThreadLocal&lt;PostingThreadState&gt;() &#123; @Override protected PostingThreadState initialValue() &#123; return new PostingThreadState(); &#125;&#125;; ThreadLocal 是一个线程内部的数据存储类，通过它可以在指定的线程中存储数据，而这段数据是不会与其他线程共享的。其内部原理是通过生成一个它包裹的泛型对象的数组，在不同的线程会有不同的数组索引值，通过这样就可以做到每个线程通过 get() 方法获取的时候，取到的只能是自己线程所对应的数据。在 EventBus 中， ThreadLocal 所包裹的是一个 PostingThreadState 类，它仅仅是封装了一些事件发送中过程所需的数据。 123456789final static class PostingThreadState &#123; //通过post方法参数传入的事件集合 final List&lt;Object&gt; eventQueue = new ArrayList&lt;Object&gt;(); boolean isPosting; //是否正在执行postSingleEvent()方法 boolean isMainThread; Subscription subscription; Object event; boolean canceled; &#125; 回到 post() 方法，我们看到其核心代码是这句： 123while (!eventQueue.isEmpty()) &#123; postSingleEvent(eventQueue.remove(0), postingState);&#125; 次调用post()的时候都会传入一个事件，这个事件会被加入到队列。而每次执行postSingleEvent()都会从队列中取出一个事件，这样不停循环取出事件处理，直到队列全部取完。再看 postSingleEvent() 方法 123456789101112131415161718192021222324252627private void postSingleEvent(Object event, PostingThreadState postingState) throws Error &#123; Class&lt;?&gt; eventClass = event.getClass(); boolean subscriptionFound = false; if (eventInheritance) &#123; //获取到eventClass所有父类的集合 List&lt;Class&lt;?&gt;&gt; eventTypes = lookupAllEventTypes(eventClass); int countTypes = eventTypes.size(); for (int h = 0; h &lt; countTypes; h++) &#123; Class&lt;?&gt; clazz = eventTypes.get(h); //左或右只要有一个为真则为真,并赋值给左 subscriptionFound |= postSingleEventForEventType(event, postingState, clazz); &#125; &#125; else &#123; subscriptionFound = postSingleEventForEventType(event, postingState, eventClass); &#125; if (!subscriptionFound) &#123; if (logNoSubscriberMessages) &#123; Log.d(TAG, \"No subscribers registered for event \" + eventClass); &#125; //参考sendNoSubscriberEvent注释 if (sendNoSubscriberEvent &amp;&amp; eventClass != NoSubscriberEvent.class &amp;&amp; eventClass != SubscriberExceptionEvent.class) &#123; post(new NoSubscriberEvent(this, event)); &#125; &#125;&#125; 还记得 EventBusBuild 中的 eventInheritance是做什么的吗？它表示一个子类事件能否响应父类的 onEvent() 方法。再往下看 lookupAllEventTypes() 它通过循环和递归一起用，将一个类的父类,接口,父类的接口,父类接口的父类,全部添加到全局静态变量 eventTypes 集合中。之所以用全局静态变量的好处在于用全局静态变量只需要将那耗时又复杂的循环+递归方法执行一次就够了，下次只需要通过 key:事件类名 来判断这个事件是否以及执行过 lookupAllEventTypes() 方法。 postSingleEventForEventType()方法12345678910111213141516171819202122232425262728private boolean postSingleEventForEventType(Object event, PostingThreadState postingState, Class&lt;?&gt; eventClass) &#123; CopyOnWriteArrayList&lt;Subscription&gt; subscriptions; synchronized (this) &#123; //所有订阅了eventClass的事件集合 subscriptions = subscriptionsByEventType.get(eventClass); &#125; if (subscriptions != null &amp;&amp; !subscriptions.isEmpty()) &#123; //回调subscription的响应方法 for (Subscription subscription : subscriptions) &#123; postingState.event = event; postingState.subscription = subscription; boolean aborted = false; try &#123; postToSubscription(subscription, event, postingState.isMainThread); aborted = postingState.canceled; &#125; finally &#123; postingState.event = null; postingState.subscription = null; postingState.canceled = false; &#125; if (aborted) &#123; break; &#125; &#125; return true; &#125; return false;&#125; 获取到所有订阅了 eventClass 的事件集合，之前有讲过， subscriptionsByEventType 是一个以 key:订阅的事件 value:订阅这个事件的所有订阅者集合 的 Map 。最后通过循环，遍历所有订阅了 eventClass 事件的订阅者，并向每一个订阅者发送事件。看它的发送事件的方法：postToSubscription(subscription, event, postingState.isMainThread);噢，又回到了和之前 Subscribe 流程中处理粘滞事件相同的方法里————对声明不同线程模式的事件做不同的响应方法，最终都是通过invokeSubscriber()反射订阅者类中的以onEvent开头的方法。 unregister()1234567891011public synchronized void unregister(Object subscriber) &#123; List&lt;Class&lt;?&gt;&gt; subscribedTypes = typesBySubscriber.get(subscriber); if (subscribedTypes != null) &#123; for (Class&lt;?&gt; eventType : subscribedTypes) &#123; //取消注册subscriber对eventType事件的响应 unsubscribeByEventType(subscriber, eventType); &#125; //当subscriber对所有事件都不响应以后,移除订阅者 typesBySubscriber.remove(subscriber); &#125;&#125; 之前讲过typesBySubscriber key:订阅者对象 value:这个订阅者订阅的事件集合，表示当前订阅者订阅了哪些事件。首先遍历要取消注册的订阅者订阅的每一个事件，调用unsubscribeByEventType(),从这个事件的所有订阅者集合中将要取消注册的订阅者移除。最后再以：当前订阅者为 key 全部订阅事件集合为 value 的一个 Map 的 Entry 移除，就完成了取消注册的全部过程。 EventBus工作原理最后我们再来从设计者的角度看一看EventBus的工作原理。 订阅的逻辑1、首先是调用register()方法注册一个订阅者A。2、遍历这个订阅者A的全部以onEvent开头的订阅方法。3、将A订阅的所有事件分别作为 key，所有能响应 key 事件的订阅者的集合作为 value，存入 Map&lt;事件，List&lt;订阅这个事件的订阅者&gt;&gt;。 4、以A的类名为 key，所有 onEvent 参数类型的类名组成的集合为 value，存入 Map&lt;订阅者，List&lt;订阅的事件&gt;&gt;。 4.1、如果是订阅了粘滞事件的订阅者，从粘滞事件缓存区获取之前发送过的粘滞事件，响应这些粘滞事件。 发送事件的逻辑1、取当前线程的发送事件封装数据，并从封装的数据中拿到发送事件的事件队列。2、将要发送的事件加入到事件队列中去。3、循环，每次发送队列中的一条事件给所有订阅了这个事件的订阅者。3.1、如果是子事件可以响应父事件的事件模式，需要先将这个事件的所有父类、接口、父类的接口、父类接口的父类都找到，并让订阅了这些父类信息的订阅者也都响应这条事件。 响应事件的逻辑1、发送事件处理完成后会将事件交给负责响应的逻辑部分。2、首先判断时间的响应模式，响应模式分为四种：PostThread 在哪个线程调用的post()方法，就在哪个线程执行响应方法。MainThread 无论是在哪个线程调用的post()方法，最终都在主线程执行响应方法。BackgroundThread 无论是在哪个线程调用的post()方法，最终都在后台线程执行响应方法。(串行执行，一次只执行一个任务，其他任务在队列中处于等待状态)Async 无论是在哪个线程调用的post()方法，最终都在后台线程执行响应方法。(并行执行，只要有任务就开一个线程让他执行) 取消注册的逻辑1、首先是调用unregister()方法拿到要取消注册的订阅者B。2、从这个类订阅的时候存入的 Map&lt;订阅者，List&lt;订阅的事件&gt;&gt; 中，拿到这个类的订阅事件集合。3、遍历订阅时间集合，在注册的时候存入的 Map&lt;事件，List&lt;订阅这个事件的订阅者&gt;&gt; 中将对应订阅事件的订阅者集合中的这个订阅者移除。 4、将步骤2中的 Map&lt;订阅者，List&lt;订阅的事件&gt;&gt; 中这个订阅者相关的 Entry 移除。","categories":[{"name":"移动开发","slug":"移动开发","permalink":"http://blogliu.com.cn/categories/移动开发/"}],"tags":[{"name":"EventBus","slug":"EventBus","permalink":"http://blogliu.com.cn/tags/EventBus/"},{"name":"Android","slug":"Android","permalink":"http://blogliu.com.cn/tags/Android/"},{"name":"GitHub","slug":"GitHub","permalink":"http://blogliu.com.cn/tags/GitHub/"}]},{"title":"2016,变成更好的自己","slug":"2016-做更好的自己","date":"2016-01-10T07:57:56.000Z","updated":"2018-11-23T08:40:17.384Z","comments":true,"path":"posts/299953da/","link":"","permalink":"http://blogliu.com.cn/posts/299953da/","excerpt":"","text":"欣赏拥有好习惯的人，比如说每天按时跑步，每晚坚持读书，每顿早餐都喝一杯牛奶。这种习惯可大可小，但它标明了一种清洁性的自律，也表达着对生活的一种偏执，它有某种程度的强迫性，但也因为此，它使人的生命质地有了不同。如果还没有找到为之奋斗的目标，那么先从坚持一个好习惯开始吧。","categories":[{"name":"心情随笔","slug":"心情随笔","permalink":"http://blogliu.com.cn/categories/心情随笔/"}],"tags":[{"name":"生活","slug":"生活","permalink":"http://blogliu.com.cn/tags/生活/"},{"name":"随笔","slug":"随笔","permalink":"http://blogliu.com.cn/tags/随笔/"}]},{"title":"EventBus使用详解","slug":"EventBus使用详解","date":"2016-01-09T15:52:53.000Z","updated":"2018-11-23T08:40:17.402Z","comments":true,"path":"posts/8d3d210c/","link":"","permalink":"http://blogliu.com.cn/posts/8d3d210c/","excerpt":"","text":"前言：EventBus出来有一段时间了，github上面也有很多开源项目中用到了EventBus。所以抽空学习顺便整理了一下。 概述EventBus是针一款对Android的发布/订阅事件总线。它可以让我们很轻松的实现在Android各个组件之间传递消息，并且代码的可读性更好，耦合度更低。 如何使用(1)首先需要定义一个消息类，该类可以不继承任何基类也不需要实现任何接口。如： 123public class MessageEvent &#123; ...... &#125; (2)在需要订阅事件的地方注册事件 1EventBus.getDefault().register(this); (3)产生事件，即发送消息 1EventBus.getDefault().post(messageEvent); (4)处理消息 123public void onEvent(MessageEvent messageEvent) &#123; ...&#125; (5)取消消息订阅 1EventBus.getDefault().unregister(this); 有何优点采用消息发布/订阅的一个很大的优点就是代码的简洁性，并且能够有效地降低消息发布者和订阅者之间的耦合度。举个例子，比如有两个界面，ActivityA和ActivityB，从ActivityA界面跳转到ActivityB界面后，ActivityB要给ActivityA发送一个消息，ActivityA收到消息后在界面上显示出来。我们最先想到的方法就是使用广播，使用广播实现此需求的代码如下：首先需要在ActivityA中定义一个广播接收器： 1234567public class MessageBroadcastReceiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; mMessageView.setText(\"Message from SecondActivity:\" + intent.getStringExtra(\"message\")); &#125;&#125; 还需要在onCreate()方法中注册广播接收器： 123456789101112@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //注册事件 EventBus.getDefault().register(this); //注册广播 IntentFilter intentFilter = new IntentFilter(\"message_broadcast\"); mBroadcastReceiver = new MessageBroadcastReceiver(); registerReceiver(mBroadcastReceiver, intentFilter); ......&#125; 然后在onDestory()方法中取消注册广播接收器： 1234567@Overrideprotected void onDestroy() &#123; super.onDestroy(); ...... //取消广播注册 unregisterReceiver(mBroadcastReceiver);&#125; 最后我们需要在ActivityB界面中发送广播消息： 12345678910111213findViewById(R.id.send_broadcast).setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; String message = mMessageET.getText().toString(); if(TextUtils.isEmpty(message)) &#123; message = \"defaule message\"; &#125; Intent intent = new Intent(); intent.setAction(\"message_broadcast\"); intent.putExtra(\"message\", message); sendBroadcast(intent); &#125; &#125;); 看着上面的实现代码，感觉也没什么不妥，挺好的！下面对比看下使用EventBus如何实现。根据文章最前面所讲的EventBus使用步骤，首先我们需要定义一个消息事件类： 12345678910111213141516public class MessageEvent &#123; private String message; public MessageEvent(String message) &#123; this.message = message; &#125; public String getMessage() &#123; return message; &#125; public void setMessage(String message) &#123; this.message = message; &#125;&#125; 在ActivityA界面中我们首先需要注册订阅事件： 12345678@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //注册事件 EventBus.getDefault().register(this); ......&#125; 然后在onDestory()方法中取消订阅： 123456@Overrideprotected void onDestroy() &#123; super.onDestroy(); //取消事件注册 EventBus.getDefault().unregister(this);&#125; 当然还要定义一个消息处理的方法： 123public void onEvent(MessageEvent messageEvent) &#123; mMessageView.setText(\"Message from SecondActivity:\" + messageEvent.getMessage());&#125; 至此，消息订阅者我们已经定义好了，我们还需要在ActivityB中发布消息： 12345678910findViewById(R.id.send).setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; String message = mMessageET.getText().toString(); if(TextUtils.isEmpty(message)) &#123; message = \"defaule message\"; &#125; EventBus.getDefault().post(new MessageEvent(message)); &#125;&#125;); 对比代码一看，有人会说了，这尼玛有什么区别嘛！说好的简洁呢？哥们，别着急嘛！我这里只是举了个简单的例子，仅仅从该例子来看，EventBus的优势没有体现出来。现在我将需求稍微改一下，ActivityA收到消息后，需要从网络服务器获取数据并将数据展示出来。如果使用广播，ActivityA中广播接收器代码应该这么写： 1234567891011121314151617181920public class MessageBroadcastReceiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; //从服务器上获取数据 ...... runOnUiThread(new Runnable() &#123; @Override public void run() &#123; //将获取的数据展示在界面上 ...... &#125; &#125;); &#125; &#125;).start(); &#125;&#125; 看到这段代码，不知道你何感想，反正我是看着很不爽，缩进层次太多，完全违反了Clean Code的原则。那使用EventBus来实现又是什么样呢？我们看一下。 12345678910public void onEventBackgroundThread(MessageEvent messageEvent) &#123; //从服务器上获取数据 ...... EventBus.getDefault().post(new ShowMessageEvent());&#125;public void onEventMainThread(ShowMessageEvent showMessageEvent) &#123; //将获取的数据展示在界面上 ......&#125; 对比一下以上两段代码就能很明显的感觉到EventBus的优势，代码简洁、层次清晰，大大提高了代码的可读性和可维护性。我这只是简单的加了一个小需求而已，随着业务越来越复杂，使用EventBus的优势愈加明显。 常用API介绍onEventXXX系列事件在上面我们已经接触到了EventBus的几个onEventXXX系列方法了。那他们有什么区别呢？ 在EventBus中的观察者通常有四种事件处理函数，分别是onEvent、onEventMainThread、onEventBackground与onEventAsync。 onEvent：如果使用onEvent作为事件处理函数，那么该事件在哪个线程发布出来的，onEvent就会在这个线程中运行，也就是说发布事件和接收事件在同一个线程。在onEvent方法中尽量避免执行耗时操作，因为有可能会引起ANR。 onEventMainThread：如果使用onEventMainThread作为事件处理函数，那么不论事件是在哪个线程中发布出来的，该事件处理函数都会在UI线程中执行。该方法可以用来更新UI，但是不能处理耗时操作。 onEvnetBackground：如果使用onEventBackgrond作为事件处理函数，那么如果事件是在UI线程中发布出来的，那么该事件处理函数就会在新的线程中运行，如果事件本来就是子线程中发布出来的，那么该事件处理函数直接在发布事件的线程中执行。 onEventAsync：使用这个函数作为事件处理函数，那么无论事件在哪个线程发布，该事件处理函数都会在新建的子线程中执行。 为了验证以上四个方法，我写了个小例子。 123456789101112131415public void onEvent(MessageEvent messageEvent) &#123; Log.e(\"onEvent\", Thread.currentThread().getName());&#125;public void onEventMainThread(MessageEvent messageEvent) &#123; Log.e(\"onEventMainThread\", Thread.currentThread().getName());&#125;public void onEventBackgroundThread(MessageEvent messageEvent) &#123; Log.e(\"onEventBackgroundThread\", Thread.currentThread().getName());&#125;public void onEventAsync(MessageEvent messageEvent) &#123; Log.e(\"onEventAsync\", Thread.currentThread().getName());&#125; 分别使用上面四个方法订阅同一事件，打印他们运行所在的线程。首先我们在UI线程中发布一条MessageEvent的消息，看下日志打印结果是什么。 1234567findViewById(R.id.send).setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Log.e(\"postEvent\", Thread.currentThread().getName()); EventBus.getDefault().post(new MessageEvent()); &#125; &#125;); 打印结果如下： 123452689-2689/com.lling.eventbusdemo E/postEvent﹕ main2689-2689/com.lling.eventbusdemo E/onEvent﹕ main2689-3064/com.lling.eventbusdemo E/onEventAsync﹕ pool-1-thread-12689-2689/com.lling.eventbusdemo E/onEventMainThread﹕ main2689-3065/com.lling.eventbusdemo E/onEventBackgroundThread﹕ pool-1-thread-2 从日志打印结果可以看出，如果在UI线程中发布事件，则onEvent也执行在UI线程，与发布事件的线程一致。onEventAsync执行在名字叫做pool-1-thread-1的新的线程中。onEventMainThread执行在UI线程。onEventBackgroundThread执行在名字叫做pool-1-thread-2的新的线程中。 我们再看看在子线程中发布一条MessageEvent的消息时，会有什么样的结果。 123456789101112findViewById(R.id.send).setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; Log.e(\"postEvent\", Thread.currentThread().getName()); EventBus.getDefault().post(new MessageEvent()); &#125; &#125;).start(); &#125; &#125;); 打印结果如下： 123453468-3945/com.lling.eventbusdemo E/postEvent﹕ Thread-1253468-3945/com.lling.eventbusdemo E/onEvent﹕ Thread-1253468-3945/com.lling.eventbusdemo E/onEventBackgroundThread﹕ Thread-1253468-3946/com.lling.eventbusdemo E/onEventAsync﹕ pool-1-thread-13468-3468/com.lling.eventbusdemo E/onEventMainThread﹕ main 从日志打印结果可以看出，如果在子线程中发布事件，则onEvent也执行在子线程，与发布事件的线程一致（都是Thread-125）。onEventBackgroundThread也与发布事件在同一线程执行。onEventAsync则在一个名叫pool-1-thread-1的新线程中执行。onEventMainThread还是在UI线程中执行。 上面一个例子充分验证，onEventXXX系列方法执行所在的线程。 黏性事件除了上面讲的普通事件外，EventBus还支持发送黏性事件。何为黏性事件呢？简单讲，就是在发送事件之后再订阅该事件也能收到该事件，跟黏性广播类似。具体用法如下： 订阅黏性事件： 1EventBus.getDefault().registerSticky(StickyModeActivity.this); 发送黏性事件： 1EventBus.getDefault().postSticky(new MessageEvent(\"test\")); 处理消息事件以及取消订阅和上面方式相同。 看个简单的黏性事件的例子，为了简单起见我这里就在一个Activity里演示了。 Activity代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class StickyModeActivity extends AppCompatActivity &#123; int index = 0; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_sticky_mode); findViewById(R.id.post).setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; EventBus.getDefault().postSticky(new MessageEvent(\"test\" + index++)); &#125; &#125;); findViewById(R.id.regist).setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; EventBus.getDefault().registerSticky(StickyModeActivity.this); &#125; &#125;); findViewById(R.id.unregist).setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; EventBus.getDefault().unregister(StickyModeActivity.this); &#125; &#125;); &#125; public void onEvent(MessageEvent messageEvent) &#123; Log.e(\"onEvent\", messageEvent.getMessage()); &#125; public void onEventMainThread(MessageEvent messageEvent) &#123; Log.e(\"onEventMainThread\", messageEvent.getMessage()); &#125; public void onEventBackgroundThread(MessageEvent messageEvent) &#123; Log.e(\"onEventBackgroundThread\", messageEvent.getMessage()); &#125; public void onEventAsync(MessageEvent messageEvent) &#123; Log.e(\"onEventAsync\", messageEvent.getMessage()); &#125;&#125; 代码很简单，界面上三个按钮，一个用来发送黏性事件，一个用来订阅事件，还有一个用来取消订阅的。首先在未订阅的情况下点击发送按钮发送一个黏性事件，然后点击订阅，会看到日志打印结果如下： 123415246-15246/com.lling.eventbusdemo E/onEvent﹕ test015246-15391/com.lling.eventbusdemo E/onEventAsync﹕ test015246-15246/com.lling.eventbusdemo E/onEventMainThread﹕ test015246-15393/com.lling.eventbusdemo E/onEventBackgroundThread﹕ test0 这就是粘性事件，能够收到订阅之前发送的消息。但是它只能收到最新的一次消息，比如说在未订阅之前已经发送了多条黏性消息了，然后再订阅只能收到最近的一条消息。这个我们可以验证一下，我们连续点击5次POST按钮发送5条黏性事件，然后再点击REGIST按钮订阅，打印结果如下： 12346980-6980/com.lling.eventbusdemo E/onEvent﹕ test46980-6980/com.lling.eventbusdemo E/onEventMainThread﹕ test46980-7049/com.lling.eventbusdemo E/onEventAsync﹕ test46980-7048/com.lling.eventbusdemo E/onEventBackgroundThread﹕ test4 由打印结果可以看出，确实是只收到最近的一条黏性事件。 好了，EventBus的使用暂时分析到这里。下一讲将讲解EventBus的源码。","categories":[{"name":"移动开发","slug":"移动开发","permalink":"http://blogliu.com.cn/categories/移动开发/"}],"tags":[{"name":"EventBus","slug":"EventBus","permalink":"http://blogliu.com.cn/tags/EventBus/"},{"name":"Android","slug":"Android","permalink":"http://blogliu.com.cn/tags/Android/"},{"name":"GitHub","slug":"GitHub","permalink":"http://blogliu.com.cn/tags/GitHub/"}]},{"title":"Hello World","slug":"hello-world","date":"2016-01-09T10:38:09.000Z","updated":"2018-11-23T08:40:17.389Z","comments":true,"path":"posts/4a17b156/","link":"","permalink":"http://blogliu.com.cn/posts/4a17b156/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}